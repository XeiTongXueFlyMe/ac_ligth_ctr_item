ARM GAS  /tmp/ccJYlA3r.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"mempool.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.rt_mp_alloc_sethook,"ax",%progbits
  20              		.align	2
  21              		.global	rt_mp_alloc_sethook
  22              		.thumb
  23              		.thumb_func
  25              	rt_mp_alloc_sethook:
  26              	.LFB15:
  27              		.file 1 "rt_thread/src/mempool.c"
   1:rt_thread/src/mempool.c **** /*
   2:rt_thread/src/mempool.c ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt_thread/src/mempool.c ****  *
   4:rt_thread/src/mempool.c ****  * SPDX-License-Identifier: Apache-2.0
   5:rt_thread/src/mempool.c ****  *
   6:rt_thread/src/mempool.c ****  * Change Logs:
   7:rt_thread/src/mempool.c ****  * Date           Author       Notes
   8:rt_thread/src/mempool.c ****  * 2006-05-27     Bernard      implement memory pool
   9:rt_thread/src/mempool.c ****  * 2006-06-03     Bernard      fix the thread timer init bug
  10:rt_thread/src/mempool.c ****  * 2006-06-30     Bernard      fix the allocate/free block bug
  11:rt_thread/src/mempool.c ****  * 2006-08-04     Bernard      add hook support
  12:rt_thread/src/mempool.c ****  * 2006-08-10     Bernard      fix interrupt bug in rt_mp_alloc
  13:rt_thread/src/mempool.c ****  * 2010-07-13     Bernard      fix RT_ALIGN issue found by kuronca
  14:rt_thread/src/mempool.c ****  * 2010-10-26     yi.qiu       add module support in rt_mp_delete
  15:rt_thread/src/mempool.c ****  * 2011-01-24     Bernard      add object allocation check.
  16:rt_thread/src/mempool.c ****  * 2012-03-22     Bernard      fix align issue in rt_mp_init and rt_mp_create.
  17:rt_thread/src/mempool.c ****  */
  18:rt_thread/src/mempool.c **** 
  19:rt_thread/src/mempool.c **** #include <rthw.h>
  20:rt_thread/src/mempool.c **** #include <rtthread.h>
  21:rt_thread/src/mempool.c **** 
  22:rt_thread/src/mempool.c **** #ifdef RT_USING_MEMPOOL
  23:rt_thread/src/mempool.c **** 
  24:rt_thread/src/mempool.c **** #ifdef RT_USING_HOOK
  25:rt_thread/src/mempool.c **** static void (*rt_mp_alloc_hook)(struct rt_mempool *mp, void *block);
  26:rt_thread/src/mempool.c **** static void (*rt_mp_free_hook)(struct rt_mempool *mp, void *block);
  27:rt_thread/src/mempool.c **** 
  28:rt_thread/src/mempool.c **** /**
  29:rt_thread/src/mempool.c ****  * @addtogroup Hook
  30:rt_thread/src/mempool.c ****  */
  31:rt_thread/src/mempool.c **** 
ARM GAS  /tmp/ccJYlA3r.s 			page 2


  32:rt_thread/src/mempool.c **** /**@{*/
  33:rt_thread/src/mempool.c **** 
  34:rt_thread/src/mempool.c **** /**
  35:rt_thread/src/mempool.c ****  * This function will set a hook function, which will be invoked when a memory
  36:rt_thread/src/mempool.c ****  * block is allocated from memory pool.
  37:rt_thread/src/mempool.c ****  *
  38:rt_thread/src/mempool.c ****  * @param hook the hook function
  39:rt_thread/src/mempool.c ****  */
  40:rt_thread/src/mempool.c **** void rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block))
  41:rt_thread/src/mempool.c **** {
  28              		.loc 1 41 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		@ link register save eliminated.
  33              	.LVL0:
  42:rt_thread/src/mempool.c ****     rt_mp_alloc_hook = hook;
  34              		.loc 1 42 0
  35 0000 014B     		ldr	r3, .L2
  36 0002 1860     		str	r0, [r3]
  37 0004 7047     		bx	lr
  38              	.L3:
  39 0006 00BF     		.align	2
  40              	.L2:
  41 0008 00000000 		.word	.LANCHOR0
  42              		.cfi_endproc
  43              	.LFE15:
  45              		.section	.text.rt_mp_free_sethook,"ax",%progbits
  46              		.align	2
  47              		.global	rt_mp_free_sethook
  48              		.thumb
  49              		.thumb_func
  51              	rt_mp_free_sethook:
  52              	.LFB16:
  43:rt_thread/src/mempool.c **** }
  44:rt_thread/src/mempool.c **** 
  45:rt_thread/src/mempool.c **** /**
  46:rt_thread/src/mempool.c ****  * This function will set a hook function, which will be invoked when a memory
  47:rt_thread/src/mempool.c ****  * block is released to memory pool.
  48:rt_thread/src/mempool.c ****  *
  49:rt_thread/src/mempool.c ****  * @param hook the hook function
  50:rt_thread/src/mempool.c ****  */
  51:rt_thread/src/mempool.c **** void rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block))
  52:rt_thread/src/mempool.c **** {
  53              		.loc 1 52 0
  54              		.cfi_startproc
  55              		@ args = 0, pretend = 0, frame = 0
  56              		@ frame_needed = 0, uses_anonymous_args = 0
  57              		@ link register save eliminated.
  58              	.LVL1:
  53:rt_thread/src/mempool.c ****     rt_mp_free_hook = hook;
  59              		.loc 1 53 0
  60 0000 014B     		ldr	r3, .L5
  61 0002 1860     		str	r0, [r3]
  62 0004 7047     		bx	lr
  63              	.L6:
  64 0006 00BF     		.align	2
ARM GAS  /tmp/ccJYlA3r.s 			page 3


  65              	.L5:
  66 0008 00000000 		.word	.LANCHOR1
  67              		.cfi_endproc
  68              	.LFE16:
  70              		.section	.text.rt_mp_init,"ax",%progbits
  71              		.align	2
  72              		.global	rt_mp_init
  73              		.thumb
  74              		.thumb_func
  76              	rt_mp_init:
  77              	.LFB17:
  54:rt_thread/src/mempool.c **** }
  55:rt_thread/src/mempool.c **** 
  56:rt_thread/src/mempool.c **** /**@}*/
  57:rt_thread/src/mempool.c **** #endif
  58:rt_thread/src/mempool.c **** 
  59:rt_thread/src/mempool.c **** /**
  60:rt_thread/src/mempool.c ****  * @addtogroup MM
  61:rt_thread/src/mempool.c ****  */
  62:rt_thread/src/mempool.c **** 
  63:rt_thread/src/mempool.c **** /**@{*/
  64:rt_thread/src/mempool.c **** 
  65:rt_thread/src/mempool.c **** /**
  66:rt_thread/src/mempool.c ****  * This function will initialize a memory pool object, normally which is used
  67:rt_thread/src/mempool.c ****  * for static object.
  68:rt_thread/src/mempool.c ****  *
  69:rt_thread/src/mempool.c ****  * @param mp the memory pool object
  70:rt_thread/src/mempool.c ****  * @param name the name of memory pool
  71:rt_thread/src/mempool.c ****  * @param start the star address of memory pool
  72:rt_thread/src/mempool.c ****  * @param size the total size of memory pool
  73:rt_thread/src/mempool.c ****  * @param block_size the size for each block
  74:rt_thread/src/mempool.c ****  *
  75:rt_thread/src/mempool.c ****  * @return RT_EOK
  76:rt_thread/src/mempool.c ****  */
  77:rt_thread/src/mempool.c **** rt_err_t rt_mp_init(struct rt_mempool *mp,
  78:rt_thread/src/mempool.c ****                     const char        *name,
  79:rt_thread/src/mempool.c ****                     void              *start,
  80:rt_thread/src/mempool.c ****                     rt_size_t          size,
  81:rt_thread/src/mempool.c ****                     rt_size_t          block_size)
  82:rt_thread/src/mempool.c **** {
  78              		.loc 1 82 0
  79              		.cfi_startproc
  80              		@ args = 4, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              	.LVL2:
  83 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  84              	.LCFI0:
  85              		.cfi_def_cfa_offset 24
  86              		.cfi_offset 4, -24
  87              		.cfi_offset 5, -20
  88              		.cfi_offset 6, -16
  89              		.cfi_offset 7, -12
  90              		.cfi_offset 8, -8
  91              		.cfi_offset 14, -4
  92 0004 8846     		mov	r8, r1
  93 0006 1546     		mov	r5, r2
  94 0008 1F46     		mov	r7, r3
ARM GAS  /tmp/ccJYlA3r.s 			page 4


  95 000a 069C     		ldr	r4, [sp, #24]
  83:rt_thread/src/mempool.c ****     rt_uint8_t *block_ptr;
  84:rt_thread/src/mempool.c ****     register rt_size_t offset;
  85:rt_thread/src/mempool.c **** 
  86:rt_thread/src/mempool.c ****     /* parameter check */
  87:rt_thread/src/mempool.c ****     RT_ASSERT(mp != RT_NULL);
  96              		.loc 1 87 0
  97 000c 0646     		mov	r6, r0
  98 000e 20B9     		cbnz	r0, .L8
  99              		.loc 1 87 0 is_stmt 0 discriminator 1
 100 0010 5722     		movs	r2, #87
 101              	.LVL3:
 102 0012 2149     		ldr	r1, .L16
 103              	.LVL4:
 104 0014 2148     		ldr	r0, .L16+4
 105              	.LVL5:
 106 0016 FFF7FEFF 		bl	rt_assert_handler
 107              	.LVL6:
 108              	.L8:
  88:rt_thread/src/mempool.c ****     RT_ASSERT(name != RT_NULL);
 109              		.loc 1 88 0 is_stmt 1
 110 001a B8F1000F 		cmp	r8, #0
 111 001e 04D1     		bne	.L9
 112              		.loc 1 88 0 is_stmt 0 discriminator 1
 113 0020 5822     		movs	r2, #88
 114 0022 1D49     		ldr	r1, .L16
 115 0024 1E48     		ldr	r0, .L16+8
 116 0026 FFF7FEFF 		bl	rt_assert_handler
 117              	.LVL7:
 118              	.L9:
  89:rt_thread/src/mempool.c ****     RT_ASSERT(start != RT_NULL);
 119              		.loc 1 89 0 is_stmt 1
 120 002a 25B9     		cbnz	r5, .L10
 121              		.loc 1 89 0 is_stmt 0 discriminator 1
 122 002c 5922     		movs	r2, #89
 123 002e 1A49     		ldr	r1, .L16
 124 0030 1C48     		ldr	r0, .L16+12
 125 0032 FFF7FEFF 		bl	rt_assert_handler
 126              	.LVL8:
 127              	.L10:
  90:rt_thread/src/mempool.c ****     RT_ASSERT(size > 0 && block_size > 0);
 128              		.loc 1 90 0 is_stmt 1
 129 0036 07B1     		cbz	r7, .L11
 130              		.loc 1 90 0 is_stmt 0 discriminator 2
 131 0038 24B9     		cbnz	r4, .L12
 132              	.L11:
 133              		.loc 1 90 0 discriminator 3
 134 003a 5A22     		movs	r2, #90
 135 003c 1649     		ldr	r1, .L16
 136 003e 1A48     		ldr	r0, .L16+16
 137 0040 FFF7FEFF 		bl	rt_assert_handler
 138              	.LVL9:
 139              	.L12:
  91:rt_thread/src/mempool.c **** 
  92:rt_thread/src/mempool.c ****     /* initialize object */
  93:rt_thread/src/mempool.c ****     rt_object_init(&(mp->parent), RT_Object_Class_MemPool, name);
 140              		.loc 1 93 0 is_stmt 1
ARM GAS  /tmp/ccJYlA3r.s 			page 5


 141 0044 4246     		mov	r2, r8
 142 0046 0821     		movs	r1, #8
 143 0048 3046     		mov	r0, r6
 144 004a FFF7FEFF 		bl	rt_object_init
 145              	.LVL10:
  94:rt_thread/src/mempool.c **** 
  95:rt_thread/src/mempool.c ****     /* initialize memory pool */
  96:rt_thread/src/mempool.c ****     mp->start_address = start;
 146              		.loc 1 96 0
 147 004e 7561     		str	r5, [r6, #20]
  97:rt_thread/src/mempool.c ****     mp->size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
 148              		.loc 1 97 0
 149 0050 27F00307 		bic	r7, r7, #3
 150              	.LVL11:
 151 0054 B761     		str	r7, [r6, #24]
  98:rt_thread/src/mempool.c **** 
  99:rt_thread/src/mempool.c ****     /* align the block size */
 100:rt_thread/src/mempool.c ****     block_size = RT_ALIGN(block_size, RT_ALIGN_SIZE);
 152              		.loc 1 100 0
 153 0056 E31C     		adds	r3, r4, #3
 154 0058 23F00303 		bic	r3, r3, #3
 155              	.LVL12:
 101:rt_thread/src/mempool.c ****     mp->block_size = block_size;
 156              		.loc 1 101 0
 157 005c F361     		str	r3, [r6, #28]
 102:rt_thread/src/mempool.c **** 
 103:rt_thread/src/mempool.c ****     /* align to align size byte */
 104:rt_thread/src/mempool.c ****     mp->block_total_count = mp->size / (mp->block_size + sizeof(rt_uint8_t *));
 158              		.loc 1 104 0
 159 005e 1A1D     		adds	r2, r3, #4
 160 0060 B7FBF2F7 		udiv	r7, r7, r2
 161 0064 7762     		str	r7, [r6, #36]
 105:rt_thread/src/mempool.c ****     mp->block_free_count  = mp->block_total_count;
 162              		.loc 1 105 0
 163 0066 B762     		str	r7, [r6, #40]
 106:rt_thread/src/mempool.c **** 
 107:rt_thread/src/mempool.c ****     /* initialize suspended thread list */
 108:rt_thread/src/mempool.c ****     rt_list_init(&(mp->suspend_thread));
 164              		.loc 1 108 0
 165 0068 06F12C03 		add	r3, r6, #44
 166              	.LVL13:
 167              	.LBB17:
 168              	.LBB18:
 169              		.file 2 "rt_thread/include/rtservice.h"
   1:rt_thread/include/rtservice.h **** /*
   2:rt_thread/include/rtservice.h ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt_thread/include/rtservice.h ****  *
   4:rt_thread/include/rtservice.h ****  * SPDX-License-Identifier: Apache-2.0
   5:rt_thread/include/rtservice.h ****  *
   6:rt_thread/include/rtservice.h ****  * Change Logs:
   7:rt_thread/include/rtservice.h ****  * Date           Author       Notes
   8:rt_thread/include/rtservice.h ****  * 2006-03-16     Bernard      the first version
   9:rt_thread/include/rtservice.h ****  * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
  10:rt_thread/include/rtservice.h ****  * 2007-06-27     Bernard      fix the rt_list_remove bug
  11:rt_thread/include/rtservice.h ****  * 2012-03-22     Bernard      rename kservice.h to rtservice.h
  12:rt_thread/include/rtservice.h ****  * 2017-11-15     JasonJia     Modify rt_slist_foreach to rt_slist_for_each_entry.
  13:rt_thread/include/rtservice.h ****  *                             Make code cleanup.
ARM GAS  /tmp/ccJYlA3r.s 			page 6


  14:rt_thread/include/rtservice.h ****  */
  15:rt_thread/include/rtservice.h **** 
  16:rt_thread/include/rtservice.h **** #ifndef __RT_SERVICE_H__
  17:rt_thread/include/rtservice.h **** #define __RT_SERVICE_H__
  18:rt_thread/include/rtservice.h **** 
  19:rt_thread/include/rtservice.h **** #ifdef __cplusplus
  20:rt_thread/include/rtservice.h **** extern "C" {
  21:rt_thread/include/rtservice.h **** #endif
  22:rt_thread/include/rtservice.h **** 
  23:rt_thread/include/rtservice.h **** /**
  24:rt_thread/include/rtservice.h ****  * @addtogroup KernelService
  25:rt_thread/include/rtservice.h ****  */
  26:rt_thread/include/rtservice.h **** 
  27:rt_thread/include/rtservice.h **** /**@{*/
  28:rt_thread/include/rtservice.h **** 
  29:rt_thread/include/rtservice.h **** /**
  30:rt_thread/include/rtservice.h ****  * rt_container_of - return the member address of ptr, if the type of ptr is the
  31:rt_thread/include/rtservice.h ****  * struct type.
  32:rt_thread/include/rtservice.h ****  */
  33:rt_thread/include/rtservice.h **** #define rt_container_of(ptr, type, member) \
  34:rt_thread/include/rtservice.h ****     ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))
  35:rt_thread/include/rtservice.h **** 
  36:rt_thread/include/rtservice.h **** 
  37:rt_thread/include/rtservice.h **** /**
  38:rt_thread/include/rtservice.h ****  * @brief initialize a list object
  39:rt_thread/include/rtservice.h ****  */
  40:rt_thread/include/rtservice.h **** #define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
  41:rt_thread/include/rtservice.h **** 
  42:rt_thread/include/rtservice.h **** /**
  43:rt_thread/include/rtservice.h ****  * @brief initialize a list
  44:rt_thread/include/rtservice.h ****  *
  45:rt_thread/include/rtservice.h ****  * @param l list to be initialized
  46:rt_thread/include/rtservice.h ****  */
  47:rt_thread/include/rtservice.h **** rt_inline void rt_list_init(rt_list_t *l)
  48:rt_thread/include/rtservice.h **** {
  49:rt_thread/include/rtservice.h ****     l->next = l->prev = l;
 170              		.loc 2 49 0
 171 006c 3363     		str	r3, [r6, #48]
 172 006e F362     		str	r3, [r6, #44]
 173              	.LVL14:
 174              	.LBE18:
 175              	.LBE17:
 109:rt_thread/src/mempool.c **** 
 110:rt_thread/src/mempool.c ****     /* initialize free block list */
 111:rt_thread/src/mempool.c ****     block_ptr = (rt_uint8_t *)mp->start_address;
 112:rt_thread/src/mempool.c ****     for (offset = 0; offset < mp->block_total_count; offset ++)
 176              		.loc 1 112 0
 177 0070 0023     		movs	r3, #0
 178 0072 05E0     		b	.L13
 179              	.LVL15:
 180              	.L14:
 113:rt_thread/src/mempool.c ****     {
 114:rt_thread/src/mempool.c ****         *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *))) =
 181              		.loc 1 114 0 discriminator 3
 182 0074 02FB03F1 		mul	r1, r2, r3
 115:rt_thread/src/mempool.c ****             (rt_uint8_t *)(block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *)));
 183              		.loc 1 115 0 discriminator 3
ARM GAS  /tmp/ccJYlA3r.s 			page 7


 184 0078 0133     		adds	r3, r3, #1
 185              	.LVL16:
 186 007a 03FB0250 		mla	r0, r3, r2, r5
 114:rt_thread/src/mempool.c ****             (rt_uint8_t *)(block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *)));
 187              		.loc 1 114 0 discriminator 3
 188 007e 6850     		str	r0, [r5, r1]
 189              	.LVL17:
 190              	.L13:
 112:rt_thread/src/mempool.c ****     {
 191              		.loc 1 112 0 discriminator 1
 192 0080 716A     		ldr	r1, [r6, #36]
 193 0082 8B42     		cmp	r3, r1
 194 0084 F6D3     		bcc	.L14
 116:rt_thread/src/mempool.c ****     }
 117:rt_thread/src/mempool.c **** 
 118:rt_thread/src/mempool.c ****     *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *))) =
 195              		.loc 1 118 0
 196 0086 013B     		subs	r3, r3, #1
 197              	.LVL18:
 198 0088 03FB02F3 		mul	r3, r3, r2
 199              	.LVL19:
 200 008c 0020     		movs	r0, #0
 201 008e E850     		str	r0, [r5, r3]
 119:rt_thread/src/mempool.c ****         RT_NULL;
 120:rt_thread/src/mempool.c **** 
 121:rt_thread/src/mempool.c ****     mp->block_list = block_ptr;
 202              		.loc 1 121 0
 203 0090 3562     		str	r5, [r6, #32]
 122:rt_thread/src/mempool.c **** 
 123:rt_thread/src/mempool.c ****     return RT_EOK;
 124:rt_thread/src/mempool.c **** }
 204              		.loc 1 124 0
 205 0092 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 206              	.LVL20:
 207              	.L17:
 208 0096 00BF     		.align	2
 209              	.L16:
 210 0098 00000000 		.word	.LANCHOR2
 211 009c 00000000 		.word	.LC0
 212 00a0 10000000 		.word	.LC1
 213 00a4 20000000 		.word	.LC2
 214 00a8 34000000 		.word	.LC3
 215              		.cfi_endproc
 216              	.LFE17:
 218              		.section	.text.rt_mp_detach,"ax",%progbits
 219              		.align	2
 220              		.global	rt_mp_detach
 221              		.thumb
 222              		.thumb_func
 224              	rt_mp_detach:
 225              	.LFB18:
 125:rt_thread/src/mempool.c **** RTM_EXPORT(rt_mp_init);
 126:rt_thread/src/mempool.c **** 
 127:rt_thread/src/mempool.c **** /**
 128:rt_thread/src/mempool.c ****  * This function will detach a memory pool from system object management.
 129:rt_thread/src/mempool.c ****  *
 130:rt_thread/src/mempool.c ****  * @param mp the memory pool object
ARM GAS  /tmp/ccJYlA3r.s 			page 8


 131:rt_thread/src/mempool.c ****  *
 132:rt_thread/src/mempool.c ****  * @return RT_EOK
 133:rt_thread/src/mempool.c ****  */
 134:rt_thread/src/mempool.c **** rt_err_t rt_mp_detach(struct rt_mempool *mp)
 135:rt_thread/src/mempool.c **** {
 226              		.loc 1 135 0
 227              		.cfi_startproc
 228              		@ args = 0, pretend = 0, frame = 0
 229              		@ frame_needed = 0, uses_anonymous_args = 0
 230              	.LVL21:
 231 0000 38B5     		push	{r3, r4, r5, lr}
 232              	.LCFI1:
 233              		.cfi_def_cfa_offset 16
 234              		.cfi_offset 3, -16
 235              		.cfi_offset 4, -12
 236              		.cfi_offset 5, -8
 237              		.cfi_offset 14, -4
 136:rt_thread/src/mempool.c ****     struct rt_thread *thread;
 137:rt_thread/src/mempool.c ****     register rt_ubase_t temp;
 138:rt_thread/src/mempool.c **** 
 139:rt_thread/src/mempool.c ****     /* parameter check */
 140:rt_thread/src/mempool.c ****     RT_ASSERT(mp != RT_NULL);
 238              		.loc 1 140 0
 239 0002 0446     		mov	r4, r0
 240 0004 20B9     		cbnz	r0, .L19
 241              		.loc 1 140 0 is_stmt 0 discriminator 1
 242 0006 8C22     		movs	r2, #140
 243 0008 1749     		ldr	r1, .L25
 244 000a 1848     		ldr	r0, .L25+4
 245              	.LVL22:
 246 000c FFF7FEFF 		bl	rt_assert_handler
 247              	.LVL23:
 248              	.L19:
 141:rt_thread/src/mempool.c ****     RT_ASSERT(rt_object_get_type(&mp->parent) == RT_Object_Class_MemPool);
 249              		.loc 1 141 0 is_stmt 1
 250 0010 2046     		mov	r0, r4
 251 0012 FFF7FEFF 		bl	rt_object_get_type
 252              	.LVL24:
 253 0016 0828     		cmp	r0, #8
 254 0018 04D0     		beq	.L20
 255              		.loc 1 141 0 is_stmt 0 discriminator 1
 256 001a 8D22     		movs	r2, #141
 257 001c 1249     		ldr	r1, .L25
 258 001e 1448     		ldr	r0, .L25+8
 259 0020 FFF7FEFF 		bl	rt_assert_handler
 260              	.LVL25:
 261              	.L20:
 142:rt_thread/src/mempool.c ****     RT_ASSERT(rt_object_is_systemobject(&mp->parent));
 262              		.loc 1 142 0 is_stmt 1
 263 0024 2046     		mov	r0, r4
 264 0026 FFF7FEFF 		bl	rt_object_is_systemobject
 265              	.LVL26:
 266 002a 90B9     		cbnz	r0, .L22
 267              		.loc 1 142 0 is_stmt 0 discriminator 1
 268 002c 8E22     		movs	r2, #142
 269 002e 0E49     		ldr	r1, .L25
 270 0030 1048     		ldr	r0, .L25+12
ARM GAS  /tmp/ccJYlA3r.s 			page 9


 271 0032 FFF7FEFF 		bl	rt_assert_handler
 272              	.LVL27:
 273 0036 0CE0     		b	.L22
 274              	.L23:
 143:rt_thread/src/mempool.c **** 
 144:rt_thread/src/mempool.c ****     /* wake up all suspended threads */
 145:rt_thread/src/mempool.c ****     while (!rt_list_isempty(&(mp->suspend_thread)))
 146:rt_thread/src/mempool.c ****     {
 147:rt_thread/src/mempool.c ****         /* disable interrupt */
 148:rt_thread/src/mempool.c ****         temp = rt_hw_interrupt_disable();
 275              		.loc 1 148 0 is_stmt 1
 276 0038 FFF7FEFF 		bl	rt_hw_interrupt_disable
 277              	.LVL28:
 278 003c 0546     		mov	r5, r0
 279              	.LVL29:
 149:rt_thread/src/mempool.c **** 
 150:rt_thread/src/mempool.c ****         /* get next suspend thread */
 151:rt_thread/src/mempool.c ****         thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
 280              		.loc 1 151 0
 281 003e E06A     		ldr	r0, [r4, #44]
 282              	.LVL30:
 152:rt_thread/src/mempool.c ****         /* set error code to RT_ERROR */
 153:rt_thread/src/mempool.c ****         thread->error = -RT_ERROR;
 283              		.loc 1 153 0
 284 0040 4FF0FF33 		mov	r3, #-1
 285 0044 C361     		str	r3, [r0, #28]
 154:rt_thread/src/mempool.c **** 
 155:rt_thread/src/mempool.c ****         /*
 156:rt_thread/src/mempool.c ****          * resume thread
 157:rt_thread/src/mempool.c ****          * In rt_thread_resume function, it will remove current thread from
 158:rt_thread/src/mempool.c ****          * suspend list
 159:rt_thread/src/mempool.c ****          */
 160:rt_thread/src/mempool.c ****         rt_thread_resume(thread);
 286              		.loc 1 160 0
 287 0046 1438     		subs	r0, r0, #20
 288              	.LVL31:
 289 0048 FFF7FEFF 		bl	rt_thread_resume
 290              	.LVL32:
 161:rt_thread/src/mempool.c **** 
 162:rt_thread/src/mempool.c ****         /* enable interrupt */
 163:rt_thread/src/mempool.c ****         rt_hw_interrupt_enable(temp);
 291              		.loc 1 163 0
 292 004c 2846     		mov	r0, r5
 293 004e FFF7FEFF 		bl	rt_hw_interrupt_enable
 294              	.LVL33:
 295              	.L22:
 145:rt_thread/src/mempool.c ****     {
 296              		.loc 1 145 0
 297 0052 04F12C03 		add	r3, r4, #44
 298              	.LBB19:
 299              	.LBB20:
  50:rt_thread/include/rtservice.h **** }
  51:rt_thread/include/rtservice.h **** 
  52:rt_thread/include/rtservice.h **** /**
  53:rt_thread/include/rtservice.h ****  * @brief insert a node after a list
  54:rt_thread/include/rtservice.h ****  *
  55:rt_thread/include/rtservice.h ****  * @param l list to insert it
ARM GAS  /tmp/ccJYlA3r.s 			page 10


  56:rt_thread/include/rtservice.h ****  * @param n new node to be inserted
  57:rt_thread/include/rtservice.h ****  */
  58:rt_thread/include/rtservice.h **** rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
  59:rt_thread/include/rtservice.h **** {
  60:rt_thread/include/rtservice.h ****     l->next->prev = n;
  61:rt_thread/include/rtservice.h ****     n->next = l->next;
  62:rt_thread/include/rtservice.h **** 
  63:rt_thread/include/rtservice.h ****     l->next = n;
  64:rt_thread/include/rtservice.h ****     n->prev = l;
  65:rt_thread/include/rtservice.h **** }
  66:rt_thread/include/rtservice.h **** 
  67:rt_thread/include/rtservice.h **** /**
  68:rt_thread/include/rtservice.h ****  * @brief insert a node before a list
  69:rt_thread/include/rtservice.h ****  *
  70:rt_thread/include/rtservice.h ****  * @param n new node to be inserted
  71:rt_thread/include/rtservice.h ****  * @param l list to insert it
  72:rt_thread/include/rtservice.h ****  */
  73:rt_thread/include/rtservice.h **** rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
  74:rt_thread/include/rtservice.h **** {
  75:rt_thread/include/rtservice.h ****     l->prev->next = n;
  76:rt_thread/include/rtservice.h ****     n->prev = l->prev;
  77:rt_thread/include/rtservice.h **** 
  78:rt_thread/include/rtservice.h ****     l->prev = n;
  79:rt_thread/include/rtservice.h ****     n->next = l;
  80:rt_thread/include/rtservice.h **** }
  81:rt_thread/include/rtservice.h **** 
  82:rt_thread/include/rtservice.h **** /**
  83:rt_thread/include/rtservice.h ****  * @brief remove node from list.
  84:rt_thread/include/rtservice.h ****  * @param n the node to remove from the list.
  85:rt_thread/include/rtservice.h ****  */
  86:rt_thread/include/rtservice.h **** rt_inline void rt_list_remove(rt_list_t *n)
  87:rt_thread/include/rtservice.h **** {
  88:rt_thread/include/rtservice.h ****     n->next->prev = n->prev;
  89:rt_thread/include/rtservice.h ****     n->prev->next = n->next;
  90:rt_thread/include/rtservice.h **** 
  91:rt_thread/include/rtservice.h ****     n->next = n->prev = n;
  92:rt_thread/include/rtservice.h **** }
  93:rt_thread/include/rtservice.h **** 
  94:rt_thread/include/rtservice.h **** /**
  95:rt_thread/include/rtservice.h ****  * @brief tests whether a list is empty
  96:rt_thread/include/rtservice.h ****  * @param l the list to test.
  97:rt_thread/include/rtservice.h ****  */
  98:rt_thread/include/rtservice.h **** rt_inline int rt_list_isempty(const rt_list_t *l)
  99:rt_thread/include/rtservice.h **** {
 100:rt_thread/include/rtservice.h ****     return l->next == l;
 300              		.loc 2 100 0
 301 0056 E26A     		ldr	r2, [r4, #44]
 302              	.LBE20:
 303              	.LBE19:
 145:rt_thread/src/mempool.c ****     {
 304              		.loc 1 145 0
 305 0058 9342     		cmp	r3, r2
 306 005a EDD1     		bne	.L23
 164:rt_thread/src/mempool.c ****     }
 165:rt_thread/src/mempool.c **** 
 166:rt_thread/src/mempool.c ****     /* detach object */
 167:rt_thread/src/mempool.c ****     rt_object_detach(&(mp->parent));
ARM GAS  /tmp/ccJYlA3r.s 			page 11


 307              		.loc 1 167 0
 308 005c 2046     		mov	r0, r4
 309 005e FFF7FEFF 		bl	rt_object_detach
 310              	.LVL34:
 168:rt_thread/src/mempool.c **** 
 169:rt_thread/src/mempool.c ****     return RT_EOK;
 170:rt_thread/src/mempool.c **** }
 311              		.loc 1 170 0
 312 0062 0020     		movs	r0, #0
 313 0064 38BD     		pop	{r3, r4, r5, pc}
 314              	.LVL35:
 315              	.L26:
 316 0066 00BF     		.align	2
 317              	.L25:
 318 0068 00000000 		.word	.LANCHOR3
 319 006c 00000000 		.word	.LC0
 320 0070 50000000 		.word	.LC4
 321 0074 8C000000 		.word	.LC5
 322              		.cfi_endproc
 323              	.LFE18:
 325              		.section	.text.rt_mp_create,"ax",%progbits
 326              		.align	2
 327              		.global	rt_mp_create
 328              		.thumb
 329              		.thumb_func
 331              	rt_mp_create:
 332              	.LFB19:
 171:rt_thread/src/mempool.c **** RTM_EXPORT(rt_mp_detach);
 172:rt_thread/src/mempool.c **** 
 173:rt_thread/src/mempool.c **** #ifdef RT_USING_HEAP
 174:rt_thread/src/mempool.c **** /**
 175:rt_thread/src/mempool.c ****  * This function will create a mempool object and allocate the memory pool from
 176:rt_thread/src/mempool.c ****  * heap.
 177:rt_thread/src/mempool.c ****  *
 178:rt_thread/src/mempool.c ****  * @param name the name of memory pool
 179:rt_thread/src/mempool.c ****  * @param block_count the count of blocks in memory pool
 180:rt_thread/src/mempool.c ****  * @param block_size the size for each block
 181:rt_thread/src/mempool.c ****  *
 182:rt_thread/src/mempool.c ****  * @return the created mempool object
 183:rt_thread/src/mempool.c ****  */
 184:rt_thread/src/mempool.c **** rt_mp_t rt_mp_create(const char *name,
 185:rt_thread/src/mempool.c ****                      rt_size_t   block_count,
 186:rt_thread/src/mempool.c ****                      rt_size_t   block_size)
 187:rt_thread/src/mempool.c **** {
 333              		.loc 1 187 0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 0
 336              		@ frame_needed = 0, uses_anonymous_args = 0
 337              	.LVL36:
 338 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 339              	.LCFI2:
 340              		.cfi_def_cfa_offset 24
 341              		.cfi_offset 4, -24
 342              		.cfi_offset 5, -20
 343              		.cfi_offset 6, -16
 344              		.cfi_offset 7, -12
 345              		.cfi_offset 8, -8
ARM GAS  /tmp/ccJYlA3r.s 			page 12


 346              		.cfi_offset 14, -4
 347 0004 0546     		mov	r5, r0
 348 0006 0E46     		mov	r6, r1
 349 0008 1446     		mov	r4, r2
 350              	.LBB21:
 188:rt_thread/src/mempool.c ****     rt_uint8_t *block_ptr;
 189:rt_thread/src/mempool.c ****     struct rt_mempool *mp;
 190:rt_thread/src/mempool.c ****     register rt_size_t offset;
 191:rt_thread/src/mempool.c **** 
 192:rt_thread/src/mempool.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 351              		.loc 1 192 0
 352 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 353              	.LVL37:
 354 000e 0746     		mov	r7, r0
 355              	.LVL38:
 356 0010 FFF7FEFF 		bl	rt_interrupt_get_nest
 357              	.LVL39:
 358 0014 50B1     		cbz	r0, .L28
 359              		.loc 1 192 0 is_stmt 0 discriminator 1
 360 0016 DFF8A880 		ldr	r8, .L38+8
 361 001a 4146     		mov	r1, r8
 362 001c 2648     		ldr	r0, .L38
 363 001e FFF7FEFF 		bl	rt_kprintf
 364              	.LVL40:
 365 0022 C022     		movs	r2, #192
 366 0024 4146     		mov	r1, r8
 367 0026 2548     		ldr	r0, .L38+4
 368 0028 FFF7FEFF 		bl	rt_assert_handler
 369              	.LVL41:
 370              	.L28:
 371              		.loc 1 192 0 discriminator 5
 372 002c 3846     		mov	r0, r7
 373 002e FFF7FEFF 		bl	rt_hw_interrupt_enable
 374              	.LVL42:
 375              	.LBE21:
 193:rt_thread/src/mempool.c **** 
 194:rt_thread/src/mempool.c ****     /* parameter check */
 195:rt_thread/src/mempool.c ****     RT_ASSERT(name != RT_NULL);
 376              		.loc 1 195 0 is_stmt 1 discriminator 5
 377 0032 25B9     		cbnz	r5, .L29
 378              		.loc 1 195 0 is_stmt 0 discriminator 1
 379 0034 C322     		movs	r2, #195
 380 0036 2249     		ldr	r1, .L38+8
 381 0038 2248     		ldr	r0, .L38+12
 382 003a FFF7FEFF 		bl	rt_assert_handler
 383              	.LVL43:
 384              	.L29:
 196:rt_thread/src/mempool.c ****     RT_ASSERT(block_count > 0 && block_size > 0);
 385              		.loc 1 196 0 is_stmt 1
 386 003e 06B1     		cbz	r6, .L30
 387              		.loc 1 196 0 is_stmt 0 discriminator 2
 388 0040 24B9     		cbnz	r4, .L31
 389              	.L30:
 390              		.loc 1 196 0 discriminator 3
 391 0042 C422     		movs	r2, #196
 392 0044 1E49     		ldr	r1, .L38+8
 393 0046 2048     		ldr	r0, .L38+16
ARM GAS  /tmp/ccJYlA3r.s 			page 13


 394 0048 FFF7FEFF 		bl	rt_assert_handler
 395              	.LVL44:
 396              	.L31:
 197:rt_thread/src/mempool.c **** 
 198:rt_thread/src/mempool.c ****     /* allocate object */
 199:rt_thread/src/mempool.c ****     mp = (struct rt_mempool *)rt_object_allocate(RT_Object_Class_MemPool, name);
 397              		.loc 1 199 0 is_stmt 1
 398 004c 2946     		mov	r1, r5
 399 004e 0820     		movs	r0, #8
 400 0050 FFF7FEFF 		bl	rt_object_allocate
 401              	.LVL45:
 200:rt_thread/src/mempool.c ****     /* allocate object failed */
 201:rt_thread/src/mempool.c ****     if (mp == RT_NULL)
 402              		.loc 1 201 0
 403 0054 0546     		mov	r5, r0
 404              	.LVL46:
 405 0056 58B3     		cbz	r0, .L36
 202:rt_thread/src/mempool.c ****         return RT_NULL;
 203:rt_thread/src/mempool.c **** 
 204:rt_thread/src/mempool.c ****     /* initialize memory pool */
 205:rt_thread/src/mempool.c ****     block_size     = RT_ALIGN(block_size, RT_ALIGN_SIZE);
 406              		.loc 1 205 0
 407 0058 0334     		adds	r4, r4, #3
 408              	.LVL47:
 409 005a 24F00303 		bic	r3, r4, #3
 410              	.LVL48:
 206:rt_thread/src/mempool.c ****     mp->block_size = block_size;
 411              		.loc 1 206 0
 412 005e C361     		str	r3, [r0, #28]
 207:rt_thread/src/mempool.c ****     mp->size       = (block_size + sizeof(rt_uint8_t *)) * block_count;
 413              		.loc 1 207 0
 414 0060 1C1D     		adds	r4, r3, #4
 415 0062 04FB06F0 		mul	r0, r4, r6
 416              	.LVL49:
 417 0066 A861     		str	r0, [r5, #24]
 208:rt_thread/src/mempool.c **** 
 209:rt_thread/src/mempool.c ****     /* allocate memory */
 210:rt_thread/src/mempool.c ****     mp->start_address = rt_malloc((block_size + sizeof(rt_uint8_t *)) *
 418              		.loc 1 210 0
 419 0068 FFF7FEFF 		bl	rt_malloc
 420              	.LVL50:
 421 006c 6861     		str	r0, [r5, #20]
 211:rt_thread/src/mempool.c ****                                   block_count);
 212:rt_thread/src/mempool.c ****     if (mp->start_address == RT_NULL)
 422              		.loc 1 212 0
 423 006e 28B9     		cbnz	r0, .L33
 213:rt_thread/src/mempool.c ****     {
 214:rt_thread/src/mempool.c ****         /* no memory, delete memory pool object */
 215:rt_thread/src/mempool.c ****         rt_object_delete(&(mp->parent));
 424              		.loc 1 215 0
 425 0070 2846     		mov	r0, r5
 426 0072 FFF7FEFF 		bl	rt_object_delete
 427              	.LVL51:
 216:rt_thread/src/mempool.c **** 
 217:rt_thread/src/mempool.c ****         return RT_NULL;
 428              		.loc 1 217 0
 429 0076 0020     		movs	r0, #0
ARM GAS  /tmp/ccJYlA3r.s 			page 14


 430 0078 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 431              	.LVL52:
 432              	.L33:
 218:rt_thread/src/mempool.c ****     }
 219:rt_thread/src/mempool.c **** 
 220:rt_thread/src/mempool.c ****     mp->block_total_count = block_count;
 433              		.loc 1 220 0
 434 007c 6E62     		str	r6, [r5, #36]
 221:rt_thread/src/mempool.c ****     mp->block_free_count  = mp->block_total_count;
 435              		.loc 1 221 0
 436 007e AE62     		str	r6, [r5, #40]
 222:rt_thread/src/mempool.c **** 
 223:rt_thread/src/mempool.c ****     /* initialize suspended thread list */
 224:rt_thread/src/mempool.c ****     rt_list_init(&(mp->suspend_thread));
 437              		.loc 1 224 0
 438 0080 05F12C03 		add	r3, r5, #44
 439              	.LVL53:
 440              	.LBB22:
 441              	.LBB23:
  49:rt_thread/include/rtservice.h **** }
 442              		.loc 2 49 0
 443 0084 2B63     		str	r3, [r5, #48]
 444 0086 EB62     		str	r3, [r5, #44]
 445              	.LVL54:
 446              	.LBE23:
 447              	.LBE22:
 225:rt_thread/src/mempool.c **** 
 226:rt_thread/src/mempool.c ****     /* initialize free block list */
 227:rt_thread/src/mempool.c ****     block_ptr = (rt_uint8_t *)mp->start_address;
 228:rt_thread/src/mempool.c ****     for (offset = 0; offset < mp->block_total_count; offset ++)
 448              		.loc 1 228 0
 449 0088 0023     		movs	r3, #0
 450 008a 05E0     		b	.L34
 451              	.LVL55:
 452              	.L35:
 229:rt_thread/src/mempool.c ****     {
 230:rt_thread/src/mempool.c ****         *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *)))
 453              		.loc 1 230 0 discriminator 3
 454 008c 04FB03F2 		mul	r2, r4, r3
 231:rt_thread/src/mempool.c ****             = block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *));
 455              		.loc 1 231 0 discriminator 3
 456 0090 0133     		adds	r3, r3, #1
 457              	.LVL56:
 458 0092 03FB0401 		mla	r1, r3, r4, r0
 459 0096 8150     		str	r1, [r0, r2]
 460              	.LVL57:
 461              	.L34:
 228:rt_thread/src/mempool.c ****     {
 462              		.loc 1 228 0 discriminator 1
 463 0098 6A6A     		ldr	r2, [r5, #36]
 464 009a 9342     		cmp	r3, r2
 465 009c F6D3     		bcc	.L35
 232:rt_thread/src/mempool.c ****     }
 233:rt_thread/src/mempool.c **** 
 234:rt_thread/src/mempool.c ****     *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *)))
 466              		.loc 1 234 0
 467 009e 013B     		subs	r3, r3, #1
ARM GAS  /tmp/ccJYlA3r.s 			page 15


 468              	.LVL58:
 469 00a0 03FB04F3 		mul	r3, r3, r4
 470              	.LVL59:
 235:rt_thread/src/mempool.c ****         = RT_NULL;
 471              		.loc 1 235 0
 472 00a4 0022     		movs	r2, #0
 473 00a6 C250     		str	r2, [r0, r3]
 236:rt_thread/src/mempool.c **** 
 237:rt_thread/src/mempool.c ****     mp->block_list = block_ptr;
 474              		.loc 1 237 0
 475 00a8 2862     		str	r0, [r5, #32]
 238:rt_thread/src/mempool.c **** 
 239:rt_thread/src/mempool.c ****     return mp;
 476              		.loc 1 239 0
 477 00aa 2846     		mov	r0, r5
 478              	.LVL60:
 479 00ac BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 480              	.LVL61:
 481              	.L36:
 202:rt_thread/src/mempool.c **** 
 482              		.loc 1 202 0
 483 00b0 0020     		movs	r0, #0
 484              	.LVL62:
 240:rt_thread/src/mempool.c **** }
 485              		.loc 1 240 0
 486 00b2 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 487              	.LVL63:
 488              	.L39:
 489 00b6 00BF     		.align	2
 490              	.L38:
 491 00b8 B4000000 		.word	.LC6
 492 00bc DC000000 		.word	.LC7
 493 00c0 00000000 		.word	.LANCHOR4
 494 00c4 10000000 		.word	.LC1
 495 00c8 E0000000 		.word	.LC8
 496              		.cfi_endproc
 497              	.LFE19:
 499              		.section	.text.rt_mp_delete,"ax",%progbits
 500              		.align	2
 501              		.global	rt_mp_delete
 502              		.thumb
 503              		.thumb_func
 505              	rt_mp_delete:
 506              	.LFB20:
 241:rt_thread/src/mempool.c **** RTM_EXPORT(rt_mp_create);
 242:rt_thread/src/mempool.c **** 
 243:rt_thread/src/mempool.c **** /**
 244:rt_thread/src/mempool.c ****  * This function will delete a memory pool and release the object memory.
 245:rt_thread/src/mempool.c ****  *
 246:rt_thread/src/mempool.c ****  * @param mp the memory pool object
 247:rt_thread/src/mempool.c ****  *
 248:rt_thread/src/mempool.c ****  * @return RT_EOK
 249:rt_thread/src/mempool.c ****  */
 250:rt_thread/src/mempool.c **** rt_err_t rt_mp_delete(rt_mp_t mp)
 251:rt_thread/src/mempool.c **** {
 507              		.loc 1 251 0
 508              		.cfi_startproc
ARM GAS  /tmp/ccJYlA3r.s 			page 16


 509              		@ args = 0, pretend = 0, frame = 0
 510              		@ frame_needed = 0, uses_anonymous_args = 0
 511              	.LVL64:
 512 0000 70B5     		push	{r4, r5, r6, lr}
 513              	.LCFI3:
 514              		.cfi_def_cfa_offset 16
 515              		.cfi_offset 4, -16
 516              		.cfi_offset 5, -12
 517              		.cfi_offset 6, -8
 518              		.cfi_offset 14, -4
 519 0002 0446     		mov	r4, r0
 520              	.LBB24:
 252:rt_thread/src/mempool.c ****     struct rt_thread *thread;
 253:rt_thread/src/mempool.c ****     register rt_ubase_t temp;
 254:rt_thread/src/mempool.c **** 
 255:rt_thread/src/mempool.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 521              		.loc 1 255 0
 522 0004 FFF7FEFF 		bl	rt_hw_interrupt_disable
 523              	.LVL65:
 524 0008 0546     		mov	r5, r0
 525              	.LVL66:
 526 000a FFF7FEFF 		bl	rt_interrupt_get_nest
 527              	.LVL67:
 528 000e 48B1     		cbz	r0, .L41
 529              		.loc 1 255 0 is_stmt 0 discriminator 1
 530 0010 214E     		ldr	r6, .L48
 531 0012 3146     		mov	r1, r6
 532 0014 2148     		ldr	r0, .L48+4
 533 0016 FFF7FEFF 		bl	rt_kprintf
 534              	.LVL68:
 535 001a FF22     		movs	r2, #255
 536 001c 3146     		mov	r1, r6
 537 001e 2048     		ldr	r0, .L48+8
 538 0020 FFF7FEFF 		bl	rt_assert_handler
 539              	.LVL69:
 540              	.L41:
 541              		.loc 1 255 0 discriminator 5
 542 0024 2846     		mov	r0, r5
 543 0026 FFF7FEFF 		bl	rt_hw_interrupt_enable
 544              	.LVL70:
 545              	.LBE24:
 256:rt_thread/src/mempool.c **** 
 257:rt_thread/src/mempool.c ****     /* parameter check */
 258:rt_thread/src/mempool.c ****     RT_ASSERT(mp != RT_NULL);
 546              		.loc 1 258 0 is_stmt 1 discriminator 5
 547 002a 2CB9     		cbnz	r4, .L42
 548              		.loc 1 258 0 is_stmt 0 discriminator 1
 549 002c 4FF48172 		mov	r2, #258
 550 0030 1949     		ldr	r1, .L48
 551 0032 1C48     		ldr	r0, .L48+12
 552 0034 FFF7FEFF 		bl	rt_assert_handler
 553              	.LVL71:
 554              	.L42:
 259:rt_thread/src/mempool.c ****     RT_ASSERT(rt_object_get_type(&mp->parent) == RT_Object_Class_MemPool);
 555              		.loc 1 259 0 is_stmt 1
 556 0038 2046     		mov	r0, r4
 557 003a FFF7FEFF 		bl	rt_object_get_type
ARM GAS  /tmp/ccJYlA3r.s 			page 17


 558              	.LVL72:
 559 003e 0828     		cmp	r0, #8
 560 0040 05D0     		beq	.L43
 561              		.loc 1 259 0 is_stmt 0 discriminator 1
 562 0042 40F20312 		movw	r2, #259
 563 0046 1449     		ldr	r1, .L48
 564 0048 1748     		ldr	r0, .L48+16
 565 004a FFF7FEFF 		bl	rt_assert_handler
 566              	.LVL73:
 567              	.L43:
 260:rt_thread/src/mempool.c ****     RT_ASSERT(rt_object_is_systemobject(&mp->parent) == RT_FALSE);
 568              		.loc 1 260 0 is_stmt 1
 569 004e 2046     		mov	r0, r4
 570 0050 FFF7FEFF 		bl	rt_object_is_systemobject
 571              	.LVL74:
 572 0054 98B1     		cbz	r0, .L45
 573              		.loc 1 260 0 is_stmt 0 discriminator 1
 574 0056 4FF48272 		mov	r2, #260
 575 005a 0F49     		ldr	r1, .L48
 576 005c 1348     		ldr	r0, .L48+20
 577 005e FFF7FEFF 		bl	rt_assert_handler
 578              	.LVL75:
 579 0062 0CE0     		b	.L45
 580              	.LVL76:
 581              	.L46:
 261:rt_thread/src/mempool.c **** 
 262:rt_thread/src/mempool.c ****     /* wake up all suspended threads */
 263:rt_thread/src/mempool.c ****     while (!rt_list_isempty(&(mp->suspend_thread)))
 264:rt_thread/src/mempool.c ****     {
 265:rt_thread/src/mempool.c ****         /* disable interrupt */
 266:rt_thread/src/mempool.c ****         temp = rt_hw_interrupt_disable();
 582              		.loc 1 266 0 is_stmt 1
 583 0064 FFF7FEFF 		bl	rt_hw_interrupt_disable
 584              	.LVL77:
 585 0068 0546     		mov	r5, r0
 586              	.LVL78:
 267:rt_thread/src/mempool.c **** 
 268:rt_thread/src/mempool.c ****         /* get next suspend thread */
 269:rt_thread/src/mempool.c ****         thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
 587              		.loc 1 269 0
 588 006a E06A     		ldr	r0, [r4, #44]
 589              	.LVL79:
 270:rt_thread/src/mempool.c ****         /* set error code to RT_ERROR */
 271:rt_thread/src/mempool.c ****         thread->error = -RT_ERROR;
 590              		.loc 1 271 0
 591 006c 4FF0FF33 		mov	r3, #-1
 592 0070 C361     		str	r3, [r0, #28]
 272:rt_thread/src/mempool.c **** 
 273:rt_thread/src/mempool.c ****         /*
 274:rt_thread/src/mempool.c ****          * resume thread
 275:rt_thread/src/mempool.c ****          * In rt_thread_resume function, it will remove current thread from
 276:rt_thread/src/mempool.c ****          * suspend list
 277:rt_thread/src/mempool.c ****          */
 278:rt_thread/src/mempool.c ****         rt_thread_resume(thread);
 593              		.loc 1 278 0
 594 0072 1438     		subs	r0, r0, #20
 595              	.LVL80:
ARM GAS  /tmp/ccJYlA3r.s 			page 18


 596 0074 FFF7FEFF 		bl	rt_thread_resume
 597              	.LVL81:
 279:rt_thread/src/mempool.c **** 
 280:rt_thread/src/mempool.c ****         /* enable interrupt */
 281:rt_thread/src/mempool.c ****         rt_hw_interrupt_enable(temp);
 598              		.loc 1 281 0
 599 0078 2846     		mov	r0, r5
 600 007a FFF7FEFF 		bl	rt_hw_interrupt_enable
 601              	.LVL82:
 602              	.L45:
 263:rt_thread/src/mempool.c ****     {
 603              		.loc 1 263 0
 604 007e 04F12C03 		add	r3, r4, #44
 605              	.LBB25:
 606              	.LBB26:
 607              		.loc 2 100 0
 608 0082 E26A     		ldr	r2, [r4, #44]
 609              	.LBE26:
 610              	.LBE25:
 263:rt_thread/src/mempool.c ****     {
 611              		.loc 1 263 0
 612 0084 9342     		cmp	r3, r2
 613 0086 EDD1     		bne	.L46
 282:rt_thread/src/mempool.c ****     }
 283:rt_thread/src/mempool.c **** 
 284:rt_thread/src/mempool.c ****     /* release allocated room */
 285:rt_thread/src/mempool.c ****     rt_free(mp->start_address);
 614              		.loc 1 285 0
 615 0088 6069     		ldr	r0, [r4, #20]
 616 008a FFF7FEFF 		bl	rt_free
 617              	.LVL83:
 286:rt_thread/src/mempool.c **** 
 287:rt_thread/src/mempool.c ****     /* detach object */
 288:rt_thread/src/mempool.c ****     rt_object_delete(&(mp->parent));
 618              		.loc 1 288 0
 619 008e 2046     		mov	r0, r4
 620 0090 FFF7FEFF 		bl	rt_object_delete
 621              	.LVL84:
 289:rt_thread/src/mempool.c **** 
 290:rt_thread/src/mempool.c ****     return RT_EOK;
 291:rt_thread/src/mempool.c **** }
 622              		.loc 1 291 0
 623 0094 0020     		movs	r0, #0
 624 0096 70BD     		pop	{r4, r5, r6, pc}
 625              	.LVL85:
 626              	.L49:
 627              		.align	2
 628              	.L48:
 629 0098 00000000 		.word	.LANCHOR5
 630 009c B4000000 		.word	.LC6
 631 00a0 DC000000 		.word	.LC7
 632 00a4 00000000 		.word	.LC0
 633 00a8 50000000 		.word	.LC4
 634 00ac 04010000 		.word	.LC9
 635              		.cfi_endproc
 636              	.LFE20:
 638              		.section	.text.rt_mp_alloc,"ax",%progbits
ARM GAS  /tmp/ccJYlA3r.s 			page 19


 639              		.align	2
 640              		.global	rt_mp_alloc
 641              		.thumb
 642              		.thumb_func
 644              	rt_mp_alloc:
 645              	.LFB21:
 292:rt_thread/src/mempool.c **** RTM_EXPORT(rt_mp_delete);
 293:rt_thread/src/mempool.c **** #endif
 294:rt_thread/src/mempool.c **** 
 295:rt_thread/src/mempool.c **** /**
 296:rt_thread/src/mempool.c ****  * This function will allocate a block from memory pool
 297:rt_thread/src/mempool.c ****  *
 298:rt_thread/src/mempool.c ****  * @param mp the memory pool object
 299:rt_thread/src/mempool.c ****  * @param time the waiting time
 300:rt_thread/src/mempool.c ****  *
 301:rt_thread/src/mempool.c ****  * @return the allocated memory block or RT_NULL on allocated failed
 302:rt_thread/src/mempool.c ****  */
 303:rt_thread/src/mempool.c **** void *rt_mp_alloc(rt_mp_t mp, rt_int32_t time)
 304:rt_thread/src/mempool.c **** {
 646              		.loc 1 304 0
 647              		.cfi_startproc
 648              		@ args = 0, pretend = 0, frame = 8
 649              		@ frame_needed = 0, uses_anonymous_args = 0
 650              	.LVL86:
 651 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 652              	.LCFI4:
 653              		.cfi_def_cfa_offset 28
 654              		.cfi_offset 4, -28
 655              		.cfi_offset 5, -24
 656              		.cfi_offset 6, -20
 657              		.cfi_offset 7, -16
 658              		.cfi_offset 8, -12
 659              		.cfi_offset 9, -8
 660              		.cfi_offset 14, -4
 661 0004 83B0     		sub	sp, sp, #12
 662              	.LCFI5:
 663              		.cfi_def_cfa_offset 40
 664 0006 0191     		str	r1, [sp, #4]
 665              	.LVL87:
 305:rt_thread/src/mempool.c ****     rt_uint8_t *block_ptr;
 306:rt_thread/src/mempool.c ****     register rt_base_t level;
 307:rt_thread/src/mempool.c ****     struct rt_thread *thread;
 308:rt_thread/src/mempool.c ****     rt_uint32_t before_sleep = 0;
 309:rt_thread/src/mempool.c **** 
 310:rt_thread/src/mempool.c ****     /* parameter check */
 311:rt_thread/src/mempool.c ****     RT_ASSERT(mp != RT_NULL);
 666              		.loc 1 311 0
 667 0008 0546     		mov	r5, r0
 668 000a 28B9     		cbnz	r0, .L51
 669              		.loc 1 311 0 is_stmt 0 discriminator 1
 670 000c 40F23712 		movw	r2, #311
 671 0010 4049     		ldr	r1, .L63
 672              	.LVL88:
 673 0012 4148     		ldr	r0, .L63+4
 674              	.LVL89:
 675 0014 FFF7FEFF 		bl	rt_assert_handler
 676              	.LVL90:
ARM GAS  /tmp/ccJYlA3r.s 			page 20


 677              	.L51:
 312:rt_thread/src/mempool.c **** 
 313:rt_thread/src/mempool.c ****     /* get current thread */
 314:rt_thread/src/mempool.c ****     thread = rt_thread_self();
 678              		.loc 1 314 0 is_stmt 1
 679 0018 FFF7FEFF 		bl	rt_thread_self
 680              	.LVL91:
 681 001c 0446     		mov	r4, r0
 682              	.LVL92:
 315:rt_thread/src/mempool.c **** 
 316:rt_thread/src/mempool.c ****     /* disable interrupt */
 317:rt_thread/src/mempool.c ****     level = rt_hw_interrupt_disable();
 683              		.loc 1 317 0
 684 001e FFF7FEFF 		bl	rt_hw_interrupt_disable
 685              	.LVL93:
 686 0022 0646     		mov	r6, r0
 687              	.LVL94:
 308:rt_thread/src/mempool.c **** 
 688              		.loc 1 308 0
 689 0024 0027     		movs	r7, #0
 318:rt_thread/src/mempool.c **** 
 319:rt_thread/src/mempool.c ****     while (mp->block_free_count == 0)
 690              		.loc 1 319 0
 691 0026 55E0     		b	.L52
 692              	.LVL95:
 693              	.L58:
 320:rt_thread/src/mempool.c ****     {
 321:rt_thread/src/mempool.c ****         /* memory block is unavailable. */
 322:rt_thread/src/mempool.c ****         if (time == 0)
 694              		.loc 1 322 0
 695 0028 019B     		ldr	r3, [sp, #4]
 696 002a 43B9     		cbnz	r3, .L53
 323:rt_thread/src/mempool.c ****         {
 324:rt_thread/src/mempool.c ****             /* enable interrupt */
 325:rt_thread/src/mempool.c ****             rt_hw_interrupt_enable(level);
 697              		.loc 1 325 0
 698 002c 3046     		mov	r0, r6
 699              	.LVL96:
 700 002e FFF7FEFF 		bl	rt_hw_interrupt_enable
 701              	.LVL97:
 326:rt_thread/src/mempool.c **** 
 327:rt_thread/src/mempool.c ****             rt_set_errno(-RT_ETIMEOUT);
 702              		.loc 1 327 0
 703 0032 6FF00100 		mvn	r0, #1
 704 0036 FFF7FEFF 		bl	rt_set_errno
 705              	.LVL98:
 328:rt_thread/src/mempool.c **** 
 329:rt_thread/src/mempool.c ****             return RT_NULL;
 706              		.loc 1 329 0
 707 003a 0020     		movs	r0, #0
 708 003c 66E0     		b	.L54
 709              	.LVL99:
 710              	.L53:
 711              	.LBB27:
 330:rt_thread/src/mempool.c ****         }
 331:rt_thread/src/mempool.c **** 
 332:rt_thread/src/mempool.c ****         RT_DEBUG_NOT_IN_INTERRUPT;
ARM GAS  /tmp/ccJYlA3r.s 			page 21


 712              		.loc 1 332 0
 713 003e FFF7FEFF 		bl	rt_hw_interrupt_disable
 714              	.LVL100:
 715 0042 8046     		mov	r8, r0
 716              	.LVL101:
 717 0044 FFF7FEFF 		bl	rt_interrupt_get_nest
 718              	.LVL102:
 719 0048 58B1     		cbz	r0, .L55
 720              		.loc 1 332 0 is_stmt 0 discriminator 1
 721 004a DFF8C890 		ldr	r9, .L63
 722 004e 4946     		mov	r1, r9
 723 0050 3248     		ldr	r0, .L63+8
 724 0052 FFF7FEFF 		bl	rt_kprintf
 725              	.LVL103:
 726 0056 4FF4A672 		mov	r2, #332
 727 005a 4946     		mov	r1, r9
 728 005c 3048     		ldr	r0, .L63+12
 729 005e FFF7FEFF 		bl	rt_assert_handler
 730              	.LVL104:
 731              	.L55:
 732              		.loc 1 332 0 discriminator 5
 733 0062 4046     		mov	r0, r8
 734 0064 FFF7FEFF 		bl	rt_hw_interrupt_enable
 735              	.LVL105:
 736              	.LBE27:
 333:rt_thread/src/mempool.c **** 
 334:rt_thread/src/mempool.c ****         thread->error = RT_EOK;
 737              		.loc 1 334 0 is_stmt 1 discriminator 5
 738 0068 0023     		movs	r3, #0
 739 006a 2363     		str	r3, [r4, #48]
 335:rt_thread/src/mempool.c **** 
 336:rt_thread/src/mempool.c ****         /* need suspend thread */
 337:rt_thread/src/mempool.c ****         rt_thread_suspend(thread);
 740              		.loc 1 337 0 discriminator 5
 741 006c 2046     		mov	r0, r4
 742 006e FFF7FEFF 		bl	rt_thread_suspend
 743              	.LVL106:
 338:rt_thread/src/mempool.c ****         rt_list_insert_after(&(mp->suspend_thread), &(thread->tlist));
 744              		.loc 1 338 0 discriminator 5
 745 0072 05F12C02 		add	r2, r5, #44
 746 0076 04F11403 		add	r3, r4, #20
 747              	.LBB28:
 748              	.LBB29:
  60:rt_thread/include/rtservice.h ****     n->next = l->next;
 749              		.loc 2 60 0 discriminator 5
 750 007a E96A     		ldr	r1, [r5, #44]
 751 007c 4B60     		str	r3, [r1, #4]
  61:rt_thread/include/rtservice.h **** 
 752              		.loc 2 61 0 discriminator 5
 753 007e E96A     		ldr	r1, [r5, #44]
 754 0080 6161     		str	r1, [r4, #20]
  63:rt_thread/include/rtservice.h ****     n->prev = l;
 755              		.loc 2 63 0 discriminator 5
 756 0082 EB62     		str	r3, [r5, #44]
  64:rt_thread/include/rtservice.h **** }
 757              		.loc 2 64 0 discriminator 5
 758 0084 A261     		str	r2, [r4, #24]
ARM GAS  /tmp/ccJYlA3r.s 			page 22


 759              	.LBE29:
 760              	.LBE28:
 339:rt_thread/src/mempool.c **** 
 340:rt_thread/src/mempool.c ****         if (time > 0)
 761              		.loc 1 340 0 discriminator 5
 762 0086 019B     		ldr	r3, [sp, #4]
 763 0088 002B     		cmp	r3, #0
 764 008a 0CDD     		ble	.L56
 341:rt_thread/src/mempool.c ****         {
 342:rt_thread/src/mempool.c ****             /* get the start tick of timer */
 343:rt_thread/src/mempool.c ****             before_sleep = rt_tick_get();
 765              		.loc 1 343 0
 766 008c FFF7FEFF 		bl	rt_tick_get
 767              	.LVL107:
 768 0090 0746     		mov	r7, r0
 769              	.LVL108:
 344:rt_thread/src/mempool.c **** 
 345:rt_thread/src/mempool.c ****             /* init thread timer and start it */
 346:rt_thread/src/mempool.c ****             rt_timer_control(&(thread->thread_timer),
 770              		.loc 1 346 0
 771 0092 04F16008 		add	r8, r4, #96
 772              	.LVL109:
 773 0096 01AA     		add	r2, sp, #4
 774              	.LVL110:
 775 0098 0021     		movs	r1, #0
 776 009a 4046     		mov	r0, r8
 777              	.LVL111:
 778 009c FFF7FEFF 		bl	rt_timer_control
 779              	.LVL112:
 347:rt_thread/src/mempool.c ****                              RT_TIMER_CTRL_SET_TIME,
 348:rt_thread/src/mempool.c ****                              &time);
 349:rt_thread/src/mempool.c ****             rt_timer_start(&(thread->thread_timer));
 780              		.loc 1 349 0
 781 00a0 4046     		mov	r0, r8
 782 00a2 FFF7FEFF 		bl	rt_timer_start
 783              	.LVL113:
 784              	.L56:
 350:rt_thread/src/mempool.c ****         }
 351:rt_thread/src/mempool.c **** 
 352:rt_thread/src/mempool.c ****         /* enable interrupt */
 353:rt_thread/src/mempool.c ****         rt_hw_interrupt_enable(level);
 785              		.loc 1 353 0
 786 00a6 3046     		mov	r0, r6
 787 00a8 FFF7FEFF 		bl	rt_hw_interrupt_enable
 788              	.LVL114:
 354:rt_thread/src/mempool.c **** 
 355:rt_thread/src/mempool.c ****         /* do a schedule */
 356:rt_thread/src/mempool.c ****         rt_schedule();
 789              		.loc 1 356 0
 790 00ac FFF7FEFF 		bl	rt_schedule
 791              	.LVL115:
 357:rt_thread/src/mempool.c **** 
 358:rt_thread/src/mempool.c ****         if (thread->error != RT_EOK)
 792              		.loc 1 358 0
 793 00b0 236B     		ldr	r3, [r4, #48]
 794 00b2 53BB     		cbnz	r3, .L61
 359:rt_thread/src/mempool.c ****             return RT_NULL;
ARM GAS  /tmp/ccJYlA3r.s 			page 23


 360:rt_thread/src/mempool.c **** 
 361:rt_thread/src/mempool.c ****         if (time > 0)
 795              		.loc 1 361 0
 796 00b4 019B     		ldr	r3, [sp, #4]
 797 00b6 002B     		cmp	r3, #0
 798 00b8 09DD     		ble	.L57
 362:rt_thread/src/mempool.c ****         {
 363:rt_thread/src/mempool.c ****             time -= rt_tick_get() - before_sleep;
 799              		.loc 1 363 0
 800 00ba FFF7FEFF 		bl	rt_tick_get
 801              	.LVL116:
 802 00be C01B     		subs	r0, r0, r7
 803 00c0 019B     		ldr	r3, [sp, #4]
 804 00c2 181A     		subs	r0, r3, r0
 805 00c4 0190     		str	r0, [sp, #4]
 364:rt_thread/src/mempool.c ****             if (time < 0)
 806              		.loc 1 364 0
 807 00c6 0028     		cmp	r0, #0
 808 00c8 01DA     		bge	.L57
 365:rt_thread/src/mempool.c ****                 time = 0;
 809              		.loc 1 365 0
 810 00ca 0023     		movs	r3, #0
 811 00cc 0193     		str	r3, [sp, #4]
 812              	.L57:
 366:rt_thread/src/mempool.c ****         }
 367:rt_thread/src/mempool.c ****         /* disable interrupt */
 368:rt_thread/src/mempool.c ****         level = rt_hw_interrupt_disable();
 813              		.loc 1 368 0
 814 00ce FFF7FEFF 		bl	rt_hw_interrupt_disable
 815              	.LVL117:
 816 00d2 0646     		mov	r6, r0
 817              	.LVL118:
 818              	.L52:
 319:rt_thread/src/mempool.c ****     {
 819              		.loc 1 319 0
 820 00d4 AB6A     		ldr	r3, [r5, #40]
 821 00d6 002B     		cmp	r3, #0
 822 00d8 A6D0     		beq	.L58
 369:rt_thread/src/mempool.c ****     }
 370:rt_thread/src/mempool.c **** 
 371:rt_thread/src/mempool.c ****     /* memory block is available. decrease the free block counter */
 372:rt_thread/src/mempool.c ****     mp->block_free_count--;
 823              		.loc 1 372 0
 824 00da 013B     		subs	r3, r3, #1
 825 00dc AB62     		str	r3, [r5, #40]
 373:rt_thread/src/mempool.c **** 
 374:rt_thread/src/mempool.c ****     /* get block from block list */
 375:rt_thread/src/mempool.c ****     block_ptr = mp->block_list;
 826              		.loc 1 375 0
 827 00de 2C6A     		ldr	r4, [r5, #32]
 828              	.LVL119:
 376:rt_thread/src/mempool.c ****     RT_ASSERT(block_ptr != RT_NULL);
 829              		.loc 1 376 0
 830 00e0 2CB9     		cbnz	r4, .L59
 831              		.loc 1 376 0 is_stmt 0 discriminator 1
 832 00e2 4FF4BC72 		mov	r2, #376
 833 00e6 0B49     		ldr	r1, .L63
ARM GAS  /tmp/ccJYlA3r.s 			page 24


 834 00e8 0E48     		ldr	r0, .L63+16
 835              	.LVL120:
 836 00ea FFF7FEFF 		bl	rt_assert_handler
 837              	.LVL121:
 838              	.L59:
 377:rt_thread/src/mempool.c **** 
 378:rt_thread/src/mempool.c ****     /* Setup the next free node. */
 379:rt_thread/src/mempool.c ****     mp->block_list = *(rt_uint8_t **)block_ptr;
 839              		.loc 1 379 0 is_stmt 1
 840 00ee 2368     		ldr	r3, [r4]
 841 00f0 2B62     		str	r3, [r5, #32]
 380:rt_thread/src/mempool.c **** 
 381:rt_thread/src/mempool.c ****     /* point to memory pool */
 382:rt_thread/src/mempool.c ****     *(rt_uint8_t **)block_ptr = (rt_uint8_t *)mp;
 842              		.loc 1 382 0
 843 00f2 2560     		str	r5, [r4]
 383:rt_thread/src/mempool.c **** 
 384:rt_thread/src/mempool.c ****     /* enable interrupt */
 385:rt_thread/src/mempool.c ****     rt_hw_interrupt_enable(level);
 844              		.loc 1 385 0
 845 00f4 3046     		mov	r0, r6
 846 00f6 FFF7FEFF 		bl	rt_hw_interrupt_enable
 847              	.LVL122:
 386:rt_thread/src/mempool.c **** 
 387:rt_thread/src/mempool.c ****     RT_OBJECT_HOOK_CALL(rt_mp_alloc_hook,
 848              		.loc 1 387 0
 849 00fa 0B4B     		ldr	r3, .L63+20
 850 00fc 1B68     		ldr	r3, [r3]
 851 00fe 13B1     		cbz	r3, .L60
 852              		.loc 1 387 0 is_stmt 0 discriminator 1
 853 0100 211D     		adds	r1, r4, #4
 854 0102 2846     		mov	r0, r5
 855 0104 9847     		blx	r3
 856              	.LVL123:
 857              	.L60:
 388:rt_thread/src/mempool.c ****                         (mp, (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *))));
 389:rt_thread/src/mempool.c **** 
 390:rt_thread/src/mempool.c ****     return (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *));
 858              		.loc 1 390 0 is_stmt 1
 859 0106 201D     		adds	r0, r4, #4
 860 0108 00E0     		b	.L54
 861              	.LVL124:
 862              	.L61:
 359:rt_thread/src/mempool.c **** 
 863              		.loc 1 359 0
 864 010a 0020     		movs	r0, #0
 865              	.LVL125:
 866              	.L54:
 391:rt_thread/src/mempool.c **** }
 867              		.loc 1 391 0
 868 010c 03B0     		add	sp, sp, #12
 869              	.LCFI6:
 870              		.cfi_def_cfa_offset 28
 871              		@ sp needed
 872 010e BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 873              	.LVL126:
 874              	.L64:
ARM GAS  /tmp/ccJYlA3r.s 			page 25


 875 0112 00BF     		.align	2
 876              	.L63:
 877 0114 00000000 		.word	.LANCHOR6
 878 0118 00000000 		.word	.LC0
 879 011c B4000000 		.word	.LC6
 880 0120 DC000000 		.word	.LC7
 881 0124 38010000 		.word	.LC10
 882 0128 00000000 		.word	.LANCHOR0
 883              		.cfi_endproc
 884              	.LFE21:
 886              		.section	.text.rt_mp_free,"ax",%progbits
 887              		.align	2
 888              		.global	rt_mp_free
 889              		.thumb
 890              		.thumb_func
 892              	rt_mp_free:
 893              	.LFB22:
 392:rt_thread/src/mempool.c **** RTM_EXPORT(rt_mp_alloc);
 393:rt_thread/src/mempool.c **** 
 394:rt_thread/src/mempool.c **** /**
 395:rt_thread/src/mempool.c ****  * This function will release a memory block
 396:rt_thread/src/mempool.c ****  *
 397:rt_thread/src/mempool.c ****  * @param block the address of memory block to be released
 398:rt_thread/src/mempool.c ****  */
 399:rt_thread/src/mempool.c **** void rt_mp_free(void *block)
 400:rt_thread/src/mempool.c **** {
 894              		.loc 1 400 0
 895              		.cfi_startproc
 896              		@ args = 0, pretend = 0, frame = 0
 897              		@ frame_needed = 0, uses_anonymous_args = 0
 898              	.LVL127:
 401:rt_thread/src/mempool.c ****     rt_uint8_t **block_ptr;
 402:rt_thread/src/mempool.c ****     struct rt_mempool *mp;
 403:rt_thread/src/mempool.c ****     struct rt_thread *thread;
 404:rt_thread/src/mempool.c ****     register rt_base_t level;
 405:rt_thread/src/mempool.c **** 
 406:rt_thread/src/mempool.c ****     /* parameter check */
 407:rt_thread/src/mempool.c ****     if (block == RT_NULL) return;
 899              		.loc 1 407 0
 900 0000 40B3     		cbz	r0, .L70
 400:rt_thread/src/mempool.c ****     rt_uint8_t **block_ptr;
 901              		.loc 1 400 0
 902 0002 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 903              	.LCFI7:
 904              		.cfi_def_cfa_offset 24
 905              		.cfi_offset 3, -24
 906              		.cfi_offset 4, -20
 907              		.cfi_offset 5, -16
 908              		.cfi_offset 6, -12
 909              		.cfi_offset 7, -8
 910              		.cfi_offset 14, -4
 911 0004 0546     		mov	r5, r0
 408:rt_thread/src/mempool.c **** 
 409:rt_thread/src/mempool.c ****     /* get the control block of pool which the block belongs to */
 410:rt_thread/src/mempool.c ****     block_ptr = (rt_uint8_t **)((rt_uint8_t *)block - sizeof(rt_uint8_t *));
 912              		.loc 1 410 0
 913 0006 071F     		subs	r7, r0, #4
ARM GAS  /tmp/ccJYlA3r.s 			page 26


 914              	.LVL128:
 411:rt_thread/src/mempool.c ****     mp        = (struct rt_mempool *)*block_ptr;
 915              		.loc 1 411 0
 916 0008 50F8044C 		ldr	r4, [r0, #-4]
 917              	.LVL129:
 412:rt_thread/src/mempool.c **** 
 413:rt_thread/src/mempool.c ****     RT_OBJECT_HOOK_CALL(rt_mp_free_hook, (mp, block));
 918              		.loc 1 413 0
 919 000c 124B     		ldr	r3, .L71
 920 000e 1B68     		ldr	r3, [r3]
 921 0010 13B1     		cbz	r3, .L67
 922              		.loc 1 413 0 is_stmt 0 discriminator 1
 923 0012 0146     		mov	r1, r0
 924 0014 2046     		mov	r0, r4
 925              	.LVL130:
 926 0016 9847     		blx	r3
 927              	.LVL131:
 928              	.L67:
 414:rt_thread/src/mempool.c **** 
 415:rt_thread/src/mempool.c ****     /* disable interrupt */
 416:rt_thread/src/mempool.c ****     level = rt_hw_interrupt_disable();
 929              		.loc 1 416 0 is_stmt 1
 930 0018 FFF7FEFF 		bl	rt_hw_interrupt_disable
 931              	.LVL132:
 932 001c 0646     		mov	r6, r0
 933              	.LVL133:
 417:rt_thread/src/mempool.c **** 
 418:rt_thread/src/mempool.c ****     /* increase the free block count */
 419:rt_thread/src/mempool.c ****     mp->block_free_count ++;
 934              		.loc 1 419 0
 935 001e A36A     		ldr	r3, [r4, #40]
 936 0020 0133     		adds	r3, r3, #1
 937 0022 A362     		str	r3, [r4, #40]
 420:rt_thread/src/mempool.c **** 
 421:rt_thread/src/mempool.c ****     /* link the block into the block list */
 422:rt_thread/src/mempool.c ****     *block_ptr = mp->block_list;
 938              		.loc 1 422 0
 939 0024 236A     		ldr	r3, [r4, #32]
 940 0026 45F8043C 		str	r3, [r5, #-4]
 423:rt_thread/src/mempool.c ****     mp->block_list = (rt_uint8_t *)block_ptr;
 941              		.loc 1 423 0
 942 002a 2762     		str	r7, [r4, #32]
 424:rt_thread/src/mempool.c **** 
 425:rt_thread/src/mempool.c ****     if (!rt_list_isempty(&(mp->suspend_thread)))
 943              		.loc 1 425 0
 944 002c 04F12C03 		add	r3, r4, #44
 945              	.LVL134:
 946              	.LBB30:
 947              	.LBB31:
 948              		.loc 2 100 0
 949 0030 E06A     		ldr	r0, [r4, #44]
 950              	.LVL135:
 951              	.LBE31:
 952              	.LBE30:
 953              		.loc 1 425 0
 954 0032 8342     		cmp	r3, r0
 955 0034 0AD0     		beq	.L68
ARM GAS  /tmp/ccJYlA3r.s 			page 27


 956              	.LVL136:
 426:rt_thread/src/mempool.c ****     {
 427:rt_thread/src/mempool.c ****         /* get the suspended thread */
 428:rt_thread/src/mempool.c ****         thread = rt_list_entry(mp->suspend_thread.next,
 429:rt_thread/src/mempool.c ****                                struct rt_thread,
 430:rt_thread/src/mempool.c ****                                tlist);
 431:rt_thread/src/mempool.c **** 
 432:rt_thread/src/mempool.c ****         /* set error */
 433:rt_thread/src/mempool.c ****         thread->error = RT_EOK;
 957              		.loc 1 433 0
 958 0036 0023     		movs	r3, #0
 959 0038 C361     		str	r3, [r0, #28]
 434:rt_thread/src/mempool.c **** 
 435:rt_thread/src/mempool.c ****         /* resume thread */
 436:rt_thread/src/mempool.c ****         rt_thread_resume(thread);
 960              		.loc 1 436 0
 961 003a 1438     		subs	r0, r0, #20
 962              	.LVL137:
 963 003c FFF7FEFF 		bl	rt_thread_resume
 964              	.LVL138:
 437:rt_thread/src/mempool.c **** 
 438:rt_thread/src/mempool.c ****         /* enable interrupt */
 439:rt_thread/src/mempool.c ****         rt_hw_interrupt_enable(level);
 965              		.loc 1 439 0
 966 0040 3046     		mov	r0, r6
 967 0042 FFF7FEFF 		bl	rt_hw_interrupt_enable
 968              	.LVL139:
 440:rt_thread/src/mempool.c **** 
 441:rt_thread/src/mempool.c ****         /* do a schedule */
 442:rt_thread/src/mempool.c ****         rt_schedule();
 969              		.loc 1 442 0
 970 0046 FFF7FEFF 		bl	rt_schedule
 971              	.LVL140:
 443:rt_thread/src/mempool.c **** 
 444:rt_thread/src/mempool.c ****         return;
 972              		.loc 1 444 0
 973 004a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 974              	.LVL141:
 975              	.L68:
 445:rt_thread/src/mempool.c ****     }
 446:rt_thread/src/mempool.c **** 
 447:rt_thread/src/mempool.c ****     /* enable interrupt */
 448:rt_thread/src/mempool.c ****     rt_hw_interrupt_enable(level);
 976              		.loc 1 448 0
 977 004c 3046     		mov	r0, r6
 978 004e FFF7FEFF 		bl	rt_hw_interrupt_enable
 979              	.LVL142:
 980 0052 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 981              	.LVL143:
 982              	.L70:
 983              	.LCFI8:
 984              		.cfi_def_cfa_offset 0
 985              		.cfi_restore 3
 986              		.cfi_restore 4
 987              		.cfi_restore 5
 988              		.cfi_restore 6
 989              		.cfi_restore 7
ARM GAS  /tmp/ccJYlA3r.s 			page 28


 990              		.cfi_restore 14
 991 0054 7047     		bx	lr
 992              	.L72:
 993 0056 00BF     		.align	2
 994              	.L71:
 995 0058 00000000 		.word	.LANCHOR1
 996              		.cfi_endproc
 997              	.LFE22:
 999              		.section	.rodata.__FUNCTION__.5355,"a",%progbits
 1000              		.align	2
 1001              		.set	.LANCHOR5,. + 0
 1004              	__FUNCTION__.5355:
 1005 0000 72745F6D 		.ascii	"rt_mp_delete\000"
 1005      705F6465 
 1005      6C657465 
 1005      00
 1006              		.section	.bss.rt_mp_alloc_hook,"aw",%nobits
 1007              		.align	2
 1008              		.set	.LANCHOR0,. + 0
 1011              	rt_mp_alloc_hook:
 1012 0000 00000000 		.space	4
 1013              		.section	.rodata.__FUNCTION__.5367,"a",%progbits
 1014              		.align	2
 1015              		.set	.LANCHOR6,. + 0
 1018              	__FUNCTION__.5367:
 1019 0000 72745F6D 		.ascii	"rt_mp_alloc\000"
 1019      705F616C 
 1019      6C6F6300 
 1020              		.section	.rodata.str1.4,"aMS",%progbits,1
 1021              		.align	2
 1022              	.LC0:
 1023 0000 6D702021 		.ascii	"mp != RT_NULL\000"
 1023      3D205254 
 1023      5F4E554C 
 1023      4C00
 1024 000e 0000     		.space	2
 1025              	.LC1:
 1026 0010 6E616D65 		.ascii	"name != RT_NULL\000"
 1026      20213D20 
 1026      52545F4E 
 1026      554C4C00 
 1027              	.LC2:
 1028 0020 73746172 		.ascii	"start != RT_NULL\000"
 1028      7420213D 
 1028      2052545F 
 1028      4E554C4C 
 1028      00
 1029 0031 000000   		.space	3
 1030              	.LC3:
 1031 0034 73697A65 		.ascii	"size > 0 && block_size > 0\000"
 1031      203E2030 
 1031      20262620 
 1031      626C6F63 
 1031      6B5F7369 
 1032 004f 00       		.space	1
 1033              	.LC4:
 1034 0050 72745F6F 		.ascii	"rt_object_get_type(&mp->parent) == RT_Object_Class_"
ARM GAS  /tmp/ccJYlA3r.s 			page 29


 1034      626A6563 
 1034      745F6765 
 1034      745F7479 
 1034      70652826 
 1035 0083 4D656D50 		.ascii	"MemPool\000"
 1035      6F6F6C00 
 1036 008b 00       		.space	1
 1037              	.LC5:
 1038 008c 72745F6F 		.ascii	"rt_object_is_systemobject(&mp->parent)\000"
 1038      626A6563 
 1038      745F6973 
 1038      5F737973 
 1038      74656D6F 
 1039 00b3 00       		.space	1
 1040              	.LC6:
 1041 00b4 46756E63 		.ascii	"Function[%s] shall not be used in ISR\012\000"
 1041      74696F6E 
 1041      5B25735D 
 1041      20736861 
 1041      6C6C206E 
 1042 00db 00       		.space	1
 1043              	.LC7:
 1044 00dc 3000     		.ascii	"0\000"
 1045 00de 0000     		.space	2
 1046              	.LC8:
 1047 00e0 626C6F63 		.ascii	"block_count > 0 && block_size > 0\000"
 1047      6B5F636F 
 1047      756E7420 
 1047      3E203020 
 1047      26262062 
 1048 0102 0000     		.space	2
 1049              	.LC9:
 1050 0104 72745F6F 		.ascii	"rt_object_is_systemobject(&mp->parent) == RT_FALSE\000"
 1050      626A6563 
 1050      745F6973 
 1050      5F737973 
 1050      74656D6F 
 1051 0137 00       		.space	1
 1052              	.LC10:
 1053 0138 626C6F63 		.ascii	"block_ptr != RT_NULL\000"
 1053      6B5F7074 
 1053      7220213D 
 1053      2052545F 
 1053      4E554C4C 
 1054              		.section	.rodata.__FUNCTION__.5323,"a",%progbits
 1055              		.align	2
 1056              		.set	.LANCHOR2,. + 0
 1059              	__FUNCTION__.5323:
 1060 0000 72745F6D 		.ascii	"rt_mp_init\000"
 1060      705F696E 
 1060      697400
 1061              		.section	.rodata.__FUNCTION__.5332,"a",%progbits
 1062              		.align	2
 1063              		.set	.LANCHOR3,. + 0
 1066              	__FUNCTION__.5332:
 1067 0000 72745F6D 		.ascii	"rt_mp_detach\000"
 1067      705F6465 
ARM GAS  /tmp/ccJYlA3r.s 			page 30


 1067      74616368 
 1067      00
 1068              		.section	.bss.rt_mp_free_hook,"aw",%nobits
 1069              		.align	2
 1070              		.set	.LANCHOR1,. + 0
 1073              	rt_mp_free_hook:
 1074 0000 00000000 		.space	4
 1075              		.section	.rodata.__FUNCTION__.5345,"a",%progbits
 1076              		.align	2
 1077              		.set	.LANCHOR4,. + 0
 1080              	__FUNCTION__.5345:
 1081 0000 72745F6D 		.ascii	"rt_mp_create\000"
 1081      705F6372 
 1081      65617465 
 1081      00
 1082              		.text
 1083              	.Letext0:
 1084              		.file 3 "rt_thread/include/rtdef.h"
 1085              		.file 4 "rt_thread/include/rtthread.h"
 1086              		.file 5 "rt_thread/include/rthw.h"
ARM GAS  /tmp/ccJYlA3r.s 			page 31


DEFINED SYMBOLS
                            *ABS*:0000000000000000 mempool.c
     /tmp/ccJYlA3r.s:20     .text.rt_mp_alloc_sethook:0000000000000000 $t
     /tmp/ccJYlA3r.s:25     .text.rt_mp_alloc_sethook:0000000000000000 rt_mp_alloc_sethook
     /tmp/ccJYlA3r.s:41     .text.rt_mp_alloc_sethook:0000000000000008 $d
     /tmp/ccJYlA3r.s:46     .text.rt_mp_free_sethook:0000000000000000 $t
     /tmp/ccJYlA3r.s:51     .text.rt_mp_free_sethook:0000000000000000 rt_mp_free_sethook
     /tmp/ccJYlA3r.s:66     .text.rt_mp_free_sethook:0000000000000008 $d
     /tmp/ccJYlA3r.s:71     .text.rt_mp_init:0000000000000000 $t
     /tmp/ccJYlA3r.s:76     .text.rt_mp_init:0000000000000000 rt_mp_init
     /tmp/ccJYlA3r.s:210    .text.rt_mp_init:0000000000000098 $d
     /tmp/ccJYlA3r.s:219    .text.rt_mp_detach:0000000000000000 $t
     /tmp/ccJYlA3r.s:224    .text.rt_mp_detach:0000000000000000 rt_mp_detach
     /tmp/ccJYlA3r.s:318    .text.rt_mp_detach:0000000000000068 $d
     /tmp/ccJYlA3r.s:326    .text.rt_mp_create:0000000000000000 $t
     /tmp/ccJYlA3r.s:331    .text.rt_mp_create:0000000000000000 rt_mp_create
     /tmp/ccJYlA3r.s:491    .text.rt_mp_create:00000000000000b8 $d
     /tmp/ccJYlA3r.s:500    .text.rt_mp_delete:0000000000000000 $t
     /tmp/ccJYlA3r.s:505    .text.rt_mp_delete:0000000000000000 rt_mp_delete
     /tmp/ccJYlA3r.s:629    .text.rt_mp_delete:0000000000000098 $d
     /tmp/ccJYlA3r.s:639    .text.rt_mp_alloc:0000000000000000 $t
     /tmp/ccJYlA3r.s:644    .text.rt_mp_alloc:0000000000000000 rt_mp_alloc
     /tmp/ccJYlA3r.s:877    .text.rt_mp_alloc:0000000000000114 $d
     /tmp/ccJYlA3r.s:887    .text.rt_mp_free:0000000000000000 $t
     /tmp/ccJYlA3r.s:892    .text.rt_mp_free:0000000000000000 rt_mp_free
     /tmp/ccJYlA3r.s:995    .text.rt_mp_free:0000000000000058 $d
     /tmp/ccJYlA3r.s:1000   .rodata.__FUNCTION__.5355:0000000000000000 $d
     /tmp/ccJYlA3r.s:1004   .rodata.__FUNCTION__.5355:0000000000000000 __FUNCTION__.5355
     /tmp/ccJYlA3r.s:1007   .bss.rt_mp_alloc_hook:0000000000000000 $d
     /tmp/ccJYlA3r.s:1011   .bss.rt_mp_alloc_hook:0000000000000000 rt_mp_alloc_hook
     /tmp/ccJYlA3r.s:1014   .rodata.__FUNCTION__.5367:0000000000000000 $d
     /tmp/ccJYlA3r.s:1018   .rodata.__FUNCTION__.5367:0000000000000000 __FUNCTION__.5367
     /tmp/ccJYlA3r.s:1021   .rodata.str1.4:0000000000000000 $d
     /tmp/ccJYlA3r.s:1055   .rodata.__FUNCTION__.5323:0000000000000000 $d
     /tmp/ccJYlA3r.s:1059   .rodata.__FUNCTION__.5323:0000000000000000 __FUNCTION__.5323
     /tmp/ccJYlA3r.s:1062   .rodata.__FUNCTION__.5332:0000000000000000 $d
     /tmp/ccJYlA3r.s:1066   .rodata.__FUNCTION__.5332:0000000000000000 __FUNCTION__.5332
     /tmp/ccJYlA3r.s:1069   .bss.rt_mp_free_hook:0000000000000000 $d
     /tmp/ccJYlA3r.s:1073   .bss.rt_mp_free_hook:0000000000000000 rt_mp_free_hook
     /tmp/ccJYlA3r.s:1076   .rodata.__FUNCTION__.5345:0000000000000000 $d
     /tmp/ccJYlA3r.s:1080   .rodata.__FUNCTION__.5345:0000000000000000 __FUNCTION__.5345
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
rt_assert_handler
rt_object_init
rt_object_get_type
rt_object_is_systemobject
rt_hw_interrupt_disable
rt_thread_resume
rt_hw_interrupt_enable
rt_object_detach
rt_interrupt_get_nest
rt_kprintf
rt_object_allocate
rt_malloc
rt_object_delete
ARM GAS  /tmp/ccJYlA3r.s 			page 32


rt_free
rt_thread_self
rt_set_errno
rt_thread_suspend
rt_tick_get
rt_timer_control
rt_timer_start
rt_schedule
