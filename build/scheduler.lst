ARM GAS  /tmp/ccbf9qME.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"scheduler.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text._rt_scheduler_stack_check,"ax",%progbits
  20              		.align	2
  21              		.thumb
  22              		.thumb_func
  24              	_rt_scheduler_stack_check:
  25              	.LFB16:
  26              		.file 1 "rt_thread/src/scheduler.c"
   1:rt_thread/src/scheduler.c **** /*
   2:rt_thread/src/scheduler.c ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt_thread/src/scheduler.c ****  *
   4:rt_thread/src/scheduler.c ****  * SPDX-License-Identifier: Apache-2.0
   5:rt_thread/src/scheduler.c ****  *
   6:rt_thread/src/scheduler.c ****  * Change Logs:
   7:rt_thread/src/scheduler.c ****  * Date           Author       Notes
   8:rt_thread/src/scheduler.c ****  * 2006-03-17     Bernard      the first version
   9:rt_thread/src/scheduler.c ****  * 2006-04-28     Bernard      fix the scheduler algorthm
  10:rt_thread/src/scheduler.c ****  * 2006-04-30     Bernard      add SCHEDULER_DEBUG
  11:rt_thread/src/scheduler.c ****  * 2006-05-27     Bernard      fix the scheduler algorthm for same priority
  12:rt_thread/src/scheduler.c ****  *                             thread schedule
  13:rt_thread/src/scheduler.c ****  * 2006-06-04     Bernard      rewrite the scheduler algorithm
  14:rt_thread/src/scheduler.c ****  * 2006-08-03     Bernard      add hook support
  15:rt_thread/src/scheduler.c ****  * 2006-09-05     Bernard      add 32 priority level support
  16:rt_thread/src/scheduler.c ****  * 2006-09-24     Bernard      add rt_system_scheduler_start function
  17:rt_thread/src/scheduler.c ****  * 2009-09-16     Bernard      fix _rt_scheduler_stack_check
  18:rt_thread/src/scheduler.c ****  * 2010-04-11     yi.qiu       add module feature
  19:rt_thread/src/scheduler.c ****  * 2010-07-13     Bernard      fix the maximal number of rt_scheduler_lock_nest
  20:rt_thread/src/scheduler.c ****  *                             issue found by kuronca
  21:rt_thread/src/scheduler.c ****  * 2010-12-13     Bernard      add defunct list initialization even if not use heap.
  22:rt_thread/src/scheduler.c ****  * 2011-05-10     Bernard      clean scheduler debug log.
  23:rt_thread/src/scheduler.c ****  * 2013-12-21     Grissiom     add rt_critical_level
  24:rt_thread/src/scheduler.c ****  */
  25:rt_thread/src/scheduler.c **** 
  26:rt_thread/src/scheduler.c **** #include <rtthread.h>
  27:rt_thread/src/scheduler.c **** #include <rthw.h>
  28:rt_thread/src/scheduler.c **** 
  29:rt_thread/src/scheduler.c **** static rt_int16_t rt_scheduler_lock_nest;
  30:rt_thread/src/scheduler.c **** extern volatile rt_uint8_t rt_interrupt_nest;
  31:rt_thread/src/scheduler.c **** 
  32:rt_thread/src/scheduler.c **** rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];
ARM GAS  /tmp/ccbf9qME.s 			page 2


  33:rt_thread/src/scheduler.c **** struct rt_thread *rt_current_thread;
  34:rt_thread/src/scheduler.c **** 
  35:rt_thread/src/scheduler.c **** rt_uint8_t rt_current_priority;
  36:rt_thread/src/scheduler.c **** 
  37:rt_thread/src/scheduler.c **** #if RT_THREAD_PRIORITY_MAX > 32
  38:rt_thread/src/scheduler.c **** /* Maximum priority level, 256 */
  39:rt_thread/src/scheduler.c **** rt_uint32_t rt_thread_ready_priority_group;
  40:rt_thread/src/scheduler.c **** rt_uint8_t rt_thread_ready_table[32];
  41:rt_thread/src/scheduler.c **** #else
  42:rt_thread/src/scheduler.c **** /* Maximum priority level, 32 */
  43:rt_thread/src/scheduler.c **** rt_uint32_t rt_thread_ready_priority_group;
  44:rt_thread/src/scheduler.c **** #endif
  45:rt_thread/src/scheduler.c **** 
  46:rt_thread/src/scheduler.c **** rt_list_t rt_thread_defunct;
  47:rt_thread/src/scheduler.c **** 
  48:rt_thread/src/scheduler.c **** #ifdef RT_USING_HOOK
  49:rt_thread/src/scheduler.c **** static void (*rt_scheduler_hook)(struct rt_thread *from, struct rt_thread *to);
  50:rt_thread/src/scheduler.c **** 
  51:rt_thread/src/scheduler.c **** /**
  52:rt_thread/src/scheduler.c ****  * @addtogroup Hook
  53:rt_thread/src/scheduler.c ****  */
  54:rt_thread/src/scheduler.c **** 
  55:rt_thread/src/scheduler.c **** /**@{*/
  56:rt_thread/src/scheduler.c **** 
  57:rt_thread/src/scheduler.c **** /**
  58:rt_thread/src/scheduler.c ****  * This function will set a hook function, which will be invoked when thread
  59:rt_thread/src/scheduler.c ****  * switch happens.
  60:rt_thread/src/scheduler.c ****  *
  61:rt_thread/src/scheduler.c ****  * @param hook the hook function
  62:rt_thread/src/scheduler.c ****  */
  63:rt_thread/src/scheduler.c **** void
  64:rt_thread/src/scheduler.c **** rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to))
  65:rt_thread/src/scheduler.c **** {
  66:rt_thread/src/scheduler.c ****     rt_scheduler_hook = hook;
  67:rt_thread/src/scheduler.c **** }
  68:rt_thread/src/scheduler.c **** 
  69:rt_thread/src/scheduler.c **** /**@}*/
  70:rt_thread/src/scheduler.c **** #endif
  71:rt_thread/src/scheduler.c **** 
  72:rt_thread/src/scheduler.c **** #ifdef RT_USING_OVERFLOW_CHECK
  73:rt_thread/src/scheduler.c **** static void _rt_scheduler_stack_check(struct rt_thread *thread)
  74:rt_thread/src/scheduler.c **** {
  27              		.loc 1 74 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 10B5     		push	{r4, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 8
  35              		.cfi_offset 4, -8
  36              		.cfi_offset 14, -4
  75:rt_thread/src/scheduler.c ****     RT_ASSERT(thread != RT_NULL);
  37              		.loc 1 75 0
  38 0002 0446     		mov	r4, r0
  39 0004 20B9     		cbnz	r0, .L2
  40              		.loc 1 75 0 is_stmt 0 discriminator 1
ARM GAS  /tmp/ccbf9qME.s 			page 3


  41 0006 4B22     		movs	r2, #75
  42 0008 0F49     		ldr	r1, .L8
  43 000a 1048     		ldr	r0, .L8+4
  44              	.LVL1:
  45 000c FFF7FEFF 		bl	rt_assert_handler
  46              	.LVL2:
  47              	.L2:
  76:rt_thread/src/scheduler.c **** 
  77:rt_thread/src/scheduler.c **** #if defined(ARCH_CPU_STACK_GROWS_UPWARD)
  78:rt_thread/src/scheduler.c ****     if (*((rt_uint8_t *)((rt_ubase_t)thread->stack_addr + thread->stack_size - 1)) != '#' ||
  79:rt_thread/src/scheduler.c **** #else
  80:rt_thread/src/scheduler.c ****     if (*((rt_uint8_t *)thread->stack_addr) != '#' ||
  48              		.loc 1 80 0 is_stmt 1
  49 0010 A36A     		ldr	r3, [r4, #40]
  50 0012 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
  51 0014 232A     		cmp	r2, #35
  52 0016 06D1     		bne	.L3
  81:rt_thread/src/scheduler.c **** #endif
  82:rt_thread/src/scheduler.c ****         (rt_ubase_t)thread->sp <= (rt_ubase_t)thread->stack_addr ||
  53              		.loc 1 82 0 discriminator 1
  54 0018 E269     		ldr	r2, [r4, #28]
  80:rt_thread/src/scheduler.c **** #endif
  55              		.loc 1 80 0 discriminator 1
  56 001a 9A42     		cmp	r2, r3
  57 001c 03D9     		bls	.L3
  83:rt_thread/src/scheduler.c ****         (rt_ubase_t)thread->sp >
  84:rt_thread/src/scheduler.c ****         (rt_ubase_t)thread->stack_addr + (rt_ubase_t)thread->stack_size)
  58              		.loc 1 84 0
  59 001e E16A     		ldr	r1, [r4, #44]
  60 0020 1944     		add	r1, r1, r3
  82:rt_thread/src/scheduler.c ****         (rt_ubase_t)thread->sp >
  61              		.loc 1 82 0
  62 0022 8A42     		cmp	r2, r1
  63 0024 08D9     		bls	.L4
  64              	.L3:
  65              	.LBB12:
  85:rt_thread/src/scheduler.c ****     {
  86:rt_thread/src/scheduler.c ****         rt_ubase_t level;
  87:rt_thread/src/scheduler.c **** 
  88:rt_thread/src/scheduler.c ****         rt_kprintf("thread:%s stack overflow\n", thread->name);
  66              		.loc 1 88 0
  67 0026 2146     		mov	r1, r4
  68 0028 0948     		ldr	r0, .L8+8
  69 002a FFF7FEFF 		bl	rt_kprintf
  70              	.LVL3:
  89:rt_thread/src/scheduler.c **** #ifdef RT_USING_FINSH
  90:rt_thread/src/scheduler.c ****         {
  91:rt_thread/src/scheduler.c ****             extern long list_thread(void);
  92:rt_thread/src/scheduler.c ****             list_thread();
  93:rt_thread/src/scheduler.c ****         }
  94:rt_thread/src/scheduler.c **** #endif
  95:rt_thread/src/scheduler.c ****         level = rt_hw_interrupt_disable();
  71              		.loc 1 95 0
  72 002e FFF7FEFF 		bl	rt_hw_interrupt_disable
  73              	.LVL4:
  74              	.L5:
  96:rt_thread/src/scheduler.c ****         while (level);
ARM GAS  /tmp/ccbf9qME.s 			page 4


  75              		.loc 1 96 0 discriminator 1
  76 0032 0028     		cmp	r0, #0
  77 0034 FDD1     		bne	.L5
  78 0036 10BD     		pop	{r4, pc}
  79              	.LVL5:
  80              	.L4:
  81              	.LBE12:
  97:rt_thread/src/scheduler.c ****     }
  98:rt_thread/src/scheduler.c **** #if defined(ARCH_CPU_STACK_GROWS_UPWARD)
  99:rt_thread/src/scheduler.c ****     else if ((rt_ubase_t)thread->sp > ((rt_ubase_t)thread->stack_addr + thread->stack_size))
 100:rt_thread/src/scheduler.c ****     {
 101:rt_thread/src/scheduler.c ****         rt_kprintf("warning: %s stack is close to the top of stack address.\n",
 102:rt_thread/src/scheduler.c ****                    thread->name);
 103:rt_thread/src/scheduler.c ****     }
 104:rt_thread/src/scheduler.c **** #else
 105:rt_thread/src/scheduler.c ****     else if ((rt_ubase_t)thread->sp <= ((rt_ubase_t)thread->stack_addr + 32))
  82              		.loc 1 105 0
  83 0038 2033     		adds	r3, r3, #32
  84 003a 9A42     		cmp	r2, r3
  85 003c 03D8     		bhi	.L1
 106:rt_thread/src/scheduler.c ****     {
 107:rt_thread/src/scheduler.c ****         rt_kprintf("warning: %s stack is close to end of stack address.\n",
  86              		.loc 1 107 0
  87 003e 2146     		mov	r1, r4
  88 0040 0448     		ldr	r0, .L8+12
  89 0042 FFF7FEFF 		bl	rt_kprintf
  90              	.LVL6:
  91              	.L1:
  92 0046 10BD     		pop	{r4, pc}
  93              	.LVL7:
  94              	.L9:
  95              		.align	2
  96              	.L8:
  97 0048 00000000 		.word	.LANCHOR0
  98 004c 00000000 		.word	.LC0
  99 0050 14000000 		.word	.LC1
 100 0054 30000000 		.word	.LC2
 101              		.cfi_endproc
 102              	.LFE16:
 104              		.section	.text.rt_scheduler_sethook,"ax",%progbits
 105              		.align	2
 106              		.global	rt_scheduler_sethook
 107              		.thumb
 108              		.thumb_func
 110              	rt_scheduler_sethook:
 111              	.LFB15:
  65:rt_thread/src/scheduler.c ****     rt_scheduler_hook = hook;
 112              		.loc 1 65 0
 113              		.cfi_startproc
 114              		@ args = 0, pretend = 0, frame = 0
 115              		@ frame_needed = 0, uses_anonymous_args = 0
 116              		@ link register save eliminated.
 117              	.LVL8:
  66:rt_thread/src/scheduler.c **** }
 118              		.loc 1 66 0
 119 0000 014B     		ldr	r3, .L11
 120 0002 1860     		str	r0, [r3]
ARM GAS  /tmp/ccbf9qME.s 			page 5


 121 0004 7047     		bx	lr
 122              	.L12:
 123 0006 00BF     		.align	2
 124              	.L11:
 125 0008 00000000 		.word	.LANCHOR1
 126              		.cfi_endproc
 127              	.LFE15:
 129              		.section	.text.rt_system_scheduler_init,"ax",%progbits
 130              		.align	2
 131              		.global	rt_system_scheduler_init
 132              		.thumb
 133              		.thumb_func
 135              	rt_system_scheduler_init:
 136              	.LFB17:
 108:rt_thread/src/scheduler.c ****                    thread->name);
 109:rt_thread/src/scheduler.c ****     }
 110:rt_thread/src/scheduler.c **** #endif
 111:rt_thread/src/scheduler.c **** }
 112:rt_thread/src/scheduler.c **** #endif
 113:rt_thread/src/scheduler.c **** 
 114:rt_thread/src/scheduler.c **** /**
 115:rt_thread/src/scheduler.c ****  * @ingroup SystemInit
 116:rt_thread/src/scheduler.c ****  * This function will initialize the system scheduler
 117:rt_thread/src/scheduler.c ****  */
 118:rt_thread/src/scheduler.c **** void rt_system_scheduler_init(void)
 119:rt_thread/src/scheduler.c **** {
 137              		.loc 1 119 0
 138              		.cfi_startproc
 139              		@ args = 0, pretend = 0, frame = 0
 140              		@ frame_needed = 0, uses_anonymous_args = 0
 141              		@ link register save eliminated.
 120:rt_thread/src/scheduler.c ****     register rt_base_t offset;
 121:rt_thread/src/scheduler.c **** 
 122:rt_thread/src/scheduler.c ****     rt_scheduler_lock_nest = 0;
 142              		.loc 1 122 0
 143 0000 0023     		movs	r3, #0
 144 0002 0C4A     		ldr	r2, .L16
 145 0004 1380     		strh	r3, [r2]	@ movhi
 146              	.LVL9:
 123:rt_thread/src/scheduler.c **** 
 124:rt_thread/src/scheduler.c ****     RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
 125:rt_thread/src/scheduler.c ****                                       RT_THREAD_PRIORITY_MAX));
 126:rt_thread/src/scheduler.c **** 
 127:rt_thread/src/scheduler.c ****     for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
 147              		.loc 1 127 0
 148 0006 06E0     		b	.L14
 149              	.LVL10:
 150              	.L15:
 128:rt_thread/src/scheduler.c ****     {
 129:rt_thread/src/scheduler.c ****         rt_list_init(&rt_thread_priority_table[offset]);
 151              		.loc 1 129 0 discriminator 3
 152 0008 0B49     		ldr	r1, .L16+4
 153 000a 01EBC302 		add	r2, r1, r3, lsl #3
 154              	.LVL11:
 155              	.LBB13:
 156              	.LBB14:
 157              		.file 2 "rt_thread/include/rtservice.h"
ARM GAS  /tmp/ccbf9qME.s 			page 6


   1:rt_thread/include/rtservice.h **** /*
   2:rt_thread/include/rtservice.h ****  * Copyright (c) 2006-2018, RT-Thread Development Team
   3:rt_thread/include/rtservice.h ****  *
   4:rt_thread/include/rtservice.h ****  * SPDX-License-Identifier: Apache-2.0
   5:rt_thread/include/rtservice.h ****  *
   6:rt_thread/include/rtservice.h ****  * Change Logs:
   7:rt_thread/include/rtservice.h ****  * Date           Author       Notes
   8:rt_thread/include/rtservice.h ****  * 2006-03-16     Bernard      the first version
   9:rt_thread/include/rtservice.h ****  * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
  10:rt_thread/include/rtservice.h ****  * 2007-06-27     Bernard      fix the rt_list_remove bug
  11:rt_thread/include/rtservice.h ****  * 2012-03-22     Bernard      rename kservice.h to rtservice.h
  12:rt_thread/include/rtservice.h ****  * 2017-11-15     JasonJia     Modify rt_slist_foreach to rt_slist_for_each_entry.
  13:rt_thread/include/rtservice.h ****  *                             Make code cleanup.
  14:rt_thread/include/rtservice.h ****  */
  15:rt_thread/include/rtservice.h **** 
  16:rt_thread/include/rtservice.h **** #ifndef __RT_SERVICE_H__
  17:rt_thread/include/rtservice.h **** #define __RT_SERVICE_H__
  18:rt_thread/include/rtservice.h **** 
  19:rt_thread/include/rtservice.h **** #ifdef __cplusplus
  20:rt_thread/include/rtservice.h **** extern "C" {
  21:rt_thread/include/rtservice.h **** #endif
  22:rt_thread/include/rtservice.h **** 
  23:rt_thread/include/rtservice.h **** /**
  24:rt_thread/include/rtservice.h ****  * @addtogroup KernelService
  25:rt_thread/include/rtservice.h ****  */
  26:rt_thread/include/rtservice.h **** 
  27:rt_thread/include/rtservice.h **** /**@{*/
  28:rt_thread/include/rtservice.h **** 
  29:rt_thread/include/rtservice.h **** /**
  30:rt_thread/include/rtservice.h ****  * rt_container_of - return the member address of ptr, if the type of ptr is the
  31:rt_thread/include/rtservice.h ****  * struct type.
  32:rt_thread/include/rtservice.h ****  */
  33:rt_thread/include/rtservice.h **** #define rt_container_of(ptr, type, member) \
  34:rt_thread/include/rtservice.h ****     ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))
  35:rt_thread/include/rtservice.h **** 
  36:rt_thread/include/rtservice.h **** 
  37:rt_thread/include/rtservice.h **** /**
  38:rt_thread/include/rtservice.h ****  * @brief initialize a list object
  39:rt_thread/include/rtservice.h ****  */
  40:rt_thread/include/rtservice.h **** #define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
  41:rt_thread/include/rtservice.h **** 
  42:rt_thread/include/rtservice.h **** /**
  43:rt_thread/include/rtservice.h ****  * @brief initialize a list
  44:rt_thread/include/rtservice.h ****  *
  45:rt_thread/include/rtservice.h ****  * @param l list to be initialized
  46:rt_thread/include/rtservice.h ****  */
  47:rt_thread/include/rtservice.h **** rt_inline void rt_list_init(rt_list_t *l)
  48:rt_thread/include/rtservice.h **** {
  49:rt_thread/include/rtservice.h ****     l->next = l->prev = l;
 158              		.loc 2 49 0 discriminator 3
 159 000e 5260     		str	r2, [r2, #4]
 160 0010 41F83320 		str	r2, [r1, r3, lsl #3]
 161              	.LVL12:
 162              	.LBE14:
 163              	.LBE13:
 127:rt_thread/src/scheduler.c ****     {
 164              		.loc 1 127 0 discriminator 3
ARM GAS  /tmp/ccbf9qME.s 			page 7


 165 0014 0133     		adds	r3, r3, #1
 166              	.LVL13:
 167              	.L14:
 127:rt_thread/src/scheduler.c ****     {
 168              		.loc 1 127 0 is_stmt 0 discriminator 1
 169 0016 1F2B     		cmp	r3, #31
 170 0018 F6DD     		ble	.L15
 130:rt_thread/src/scheduler.c ****     }
 131:rt_thread/src/scheduler.c **** 
 132:rt_thread/src/scheduler.c ****     rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
 171              		.loc 1 132 0 is_stmt 1
 172 001a 1F22     		movs	r2, #31
 173 001c 074B     		ldr	r3, .L16+8
 174              	.LVL14:
 175 001e 1A70     		strb	r2, [r3]
 133:rt_thread/src/scheduler.c ****     rt_current_thread = RT_NULL;
 176              		.loc 1 133 0
 177 0020 0023     		movs	r3, #0
 178 0022 074A     		ldr	r2, .L16+12
 179 0024 1360     		str	r3, [r2]
 134:rt_thread/src/scheduler.c **** 
 135:rt_thread/src/scheduler.c ****     /* initialize ready priority group */
 136:rt_thread/src/scheduler.c ****     rt_thread_ready_priority_group = 0;
 180              		.loc 1 136 0
 181 0026 074A     		ldr	r2, .L16+16
 182 0028 1360     		str	r3, [r2]
 183              	.LVL15:
 184              	.LBB15:
 185              	.LBB16:
 186              		.loc 2 49 0
 187 002a 074B     		ldr	r3, .L16+20
 188 002c 5B60     		str	r3, [r3, #4]
 189 002e 1B60     		str	r3, [r3]
 190              	.LVL16:
 191 0030 7047     		bx	lr
 192              	.L17:
 193 0032 00BF     		.align	2
 194              	.L16:
 195 0034 00000000 		.word	.LANCHOR2
 196 0038 00000000 		.word	rt_thread_priority_table
 197 003c 00000000 		.word	rt_current_priority
 198 0040 00000000 		.word	rt_current_thread
 199 0044 00000000 		.word	rt_thread_ready_priority_group
 200 0048 00000000 		.word	rt_thread_defunct
 201              	.LBE16:
 202              	.LBE15:
 203              		.cfi_endproc
 204              	.LFE17:
 206              		.section	.text.rt_system_scheduler_start,"ax",%progbits
 207              		.align	2
 208              		.global	rt_system_scheduler_start
 209              		.thumb
 210              		.thumb_func
 212              	rt_system_scheduler_start:
 213              	.LFB18:
 137:rt_thread/src/scheduler.c **** 
 138:rt_thread/src/scheduler.c **** #if RT_THREAD_PRIORITY_MAX > 32
ARM GAS  /tmp/ccbf9qME.s 			page 8


 139:rt_thread/src/scheduler.c ****     /* initialize ready table */
 140:rt_thread/src/scheduler.c ****     rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
 141:rt_thread/src/scheduler.c **** #endif
 142:rt_thread/src/scheduler.c **** 
 143:rt_thread/src/scheduler.c ****     /* initialize thread defunct */
 144:rt_thread/src/scheduler.c ****     rt_list_init(&rt_thread_defunct);
 145:rt_thread/src/scheduler.c **** }
 146:rt_thread/src/scheduler.c **** 
 147:rt_thread/src/scheduler.c **** /**
 148:rt_thread/src/scheduler.c ****  * @ingroup SystemInit
 149:rt_thread/src/scheduler.c ****  * This function will startup scheduler. It will select one thread
 150:rt_thread/src/scheduler.c ****  * with the highest priority level, then switch to it.
 151:rt_thread/src/scheduler.c ****  */
 152:rt_thread/src/scheduler.c **** void rt_system_scheduler_start(void)
 153:rt_thread/src/scheduler.c **** {
 214              		.loc 1 153 0
 215              		.cfi_startproc
 216              		@ args = 0, pretend = 0, frame = 0
 217              		@ frame_needed = 0, uses_anonymous_args = 0
 218 0000 08B5     		push	{r3, lr}
 219              	.LCFI1:
 220              		.cfi_def_cfa_offset 8
 221              		.cfi_offset 3, -8
 222              		.cfi_offset 14, -4
 154:rt_thread/src/scheduler.c ****     register struct rt_thread *to_thread;
 155:rt_thread/src/scheduler.c ****     register rt_ubase_t highest_ready_priority;
 156:rt_thread/src/scheduler.c **** 
 157:rt_thread/src/scheduler.c **** #if RT_THREAD_PRIORITY_MAX > 32
 158:rt_thread/src/scheduler.c ****     register rt_ubase_t number;
 159:rt_thread/src/scheduler.c **** 
 160:rt_thread/src/scheduler.c ****     number = __rt_ffs(rt_thread_ready_priority_group) - 1;
 161:rt_thread/src/scheduler.c ****     highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
 162:rt_thread/src/scheduler.c **** #else
 163:rt_thread/src/scheduler.c ****     highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 223              		.loc 1 163 0
 224 0002 084B     		ldr	r3, .L20
 225 0004 1868     		ldr	r0, [r3]
 226 0006 FFF7FEFF 		bl	__rt_ffs
 227              	.LVL17:
 228 000a 0138     		subs	r0, r0, #1
 229              	.LVL18:
 164:rt_thread/src/scheduler.c **** #endif
 165:rt_thread/src/scheduler.c **** 
 166:rt_thread/src/scheduler.c ****     /* get switch to thread */
 167:rt_thread/src/scheduler.c ****     to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
 230              		.loc 1 167 0
 231 000c 064B     		ldr	r3, .L20+4
 232 000e 53F83000 		ldr	r0, [r3, r0, lsl #3]
 233              	.LVL19:
 234 0012 A0F11402 		sub	r2, r0, #20
 235              	.LVL20:
 168:rt_thread/src/scheduler.c ****                               struct rt_thread,
 169:rt_thread/src/scheduler.c ****                               tlist);
 170:rt_thread/src/scheduler.c **** 
 171:rt_thread/src/scheduler.c ****     rt_current_thread = to_thread;
 236              		.loc 1 171 0
 237 0016 054B     		ldr	r3, .L20+8
ARM GAS  /tmp/ccbf9qME.s 			page 9


 238 0018 1A60     		str	r2, [r3]
 172:rt_thread/src/scheduler.c **** 
 173:rt_thread/src/scheduler.c ****     /* switch to new thread */
 174:rt_thread/src/scheduler.c ****     rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
 239              		.loc 1 174 0
 240 001a 0830     		adds	r0, r0, #8
 241 001c FFF7FEFF 		bl	rt_hw_context_switch_to
 242              	.LVL21:
 243 0020 08BD     		pop	{r3, pc}
 244              	.L21:
 245 0022 00BF     		.align	2
 246              	.L20:
 247 0024 00000000 		.word	rt_thread_ready_priority_group
 248 0028 00000000 		.word	rt_thread_priority_table
 249 002c 00000000 		.word	rt_current_thread
 250              		.cfi_endproc
 251              	.LFE18:
 253              		.section	.text.rt_schedule,"ax",%progbits
 254              		.align	2
 255              		.global	rt_schedule
 256              		.thumb
 257              		.thumb_func
 259              	rt_schedule:
 260              	.LFB19:
 175:rt_thread/src/scheduler.c **** 
 176:rt_thread/src/scheduler.c ****     /* never come back */
 177:rt_thread/src/scheduler.c **** }
 178:rt_thread/src/scheduler.c **** 
 179:rt_thread/src/scheduler.c **** /**
 180:rt_thread/src/scheduler.c ****  * @addtogroup Thread
 181:rt_thread/src/scheduler.c ****  */
 182:rt_thread/src/scheduler.c **** 
 183:rt_thread/src/scheduler.c **** /**@{*/
 184:rt_thread/src/scheduler.c **** 
 185:rt_thread/src/scheduler.c **** /**
 186:rt_thread/src/scheduler.c ****  * This function will perform one schedule. It will select one thread
 187:rt_thread/src/scheduler.c ****  * with the highest priority level, then switch to it.
 188:rt_thread/src/scheduler.c ****  */
 189:rt_thread/src/scheduler.c **** void rt_schedule(void)
 190:rt_thread/src/scheduler.c **** {
 261              		.loc 1 190 0
 262              		.cfi_startproc
 263              		@ args = 0, pretend = 0, frame = 0
 264              		@ frame_needed = 0, uses_anonymous_args = 0
 265 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 266              	.LCFI2:
 267              		.cfi_def_cfa_offset 24
 268              		.cfi_offset 3, -24
 269              		.cfi_offset 4, -20
 270              		.cfi_offset 5, -16
 271              		.cfi_offset 6, -12
 272              		.cfi_offset 7, -8
 273              		.cfi_offset 14, -4
 191:rt_thread/src/scheduler.c ****     rt_base_t level;
 192:rt_thread/src/scheduler.c ****     struct rt_thread *to_thread;
 193:rt_thread/src/scheduler.c ****     struct rt_thread *from_thread;
 194:rt_thread/src/scheduler.c **** 
ARM GAS  /tmp/ccbf9qME.s 			page 10


 195:rt_thread/src/scheduler.c ****     /* disable interrupt */
 196:rt_thread/src/scheduler.c ****     level = rt_hw_interrupt_disable();
 274              		.loc 1 196 0
 275 0002 FFF7FEFF 		bl	rt_hw_interrupt_disable
 276              	.LVL22:
 277 0006 0546     		mov	r5, r0
 278              	.LVL23:
 197:rt_thread/src/scheduler.c **** 
 198:rt_thread/src/scheduler.c ****     /* check the scheduler is enabled or not */
 199:rt_thread/src/scheduler.c ****     if (rt_scheduler_lock_nest == 0)
 279              		.loc 1 199 0
 280 0008 254B     		ldr	r3, .L29
 281 000a B3F90030 		ldrsh	r3, [r3]
 282 000e 002B     		cmp	r3, #0
 283 0010 41D1     		bne	.L23
 284              	.LBB17:
 200:rt_thread/src/scheduler.c ****     {
 201:rt_thread/src/scheduler.c ****         register rt_ubase_t highest_ready_priority;
 202:rt_thread/src/scheduler.c **** 
 203:rt_thread/src/scheduler.c **** #if RT_THREAD_PRIORITY_MAX <= 32
 204:rt_thread/src/scheduler.c ****         highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
 285              		.loc 1 204 0
 286 0012 244B     		ldr	r3, .L29+4
 287 0014 1868     		ldr	r0, [r3]
 288              	.LVL24:
 289 0016 FFF7FEFF 		bl	__rt_ffs
 290              	.LVL25:
 291 001a 0138     		subs	r0, r0, #1
 292              	.LVL26:
 205:rt_thread/src/scheduler.c **** #else
 206:rt_thread/src/scheduler.c ****         register rt_ubase_t number;
 207:rt_thread/src/scheduler.c **** 
 208:rt_thread/src/scheduler.c ****         number = __rt_ffs(rt_thread_ready_priority_group) - 1;
 209:rt_thread/src/scheduler.c ****         highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
 210:rt_thread/src/scheduler.c **** #endif
 211:rt_thread/src/scheduler.c **** 
 212:rt_thread/src/scheduler.c ****         /* get switch to thread */
 213:rt_thread/src/scheduler.c ****         to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
 293              		.loc 1 213 0
 294 001c 224B     		ldr	r3, .L29+8
 295 001e 53F83070 		ldr	r7, [r3, r0, lsl #3]
 296 0022 A7F11404 		sub	r4, r7, #20
 297              	.LVL27:
 214:rt_thread/src/scheduler.c ****                                   struct rt_thread,
 215:rt_thread/src/scheduler.c ****                                   tlist);
 216:rt_thread/src/scheduler.c **** 
 217:rt_thread/src/scheduler.c ****         /* if the destination thread is not the same as current thread */
 218:rt_thread/src/scheduler.c ****         if (to_thread != rt_current_thread)
 298              		.loc 1 218 0
 299 0026 214B     		ldr	r3, .L29+12
 300 0028 1E68     		ldr	r6, [r3]
 301 002a B442     		cmp	r4, r6
 302 002c 33D0     		beq	.L23
 219:rt_thread/src/scheduler.c ****         {
 220:rt_thread/src/scheduler.c ****             rt_current_priority = (rt_uint8_t)highest_ready_priority;
 303              		.loc 1 220 0
 304 002e 204B     		ldr	r3, .L29+16
ARM GAS  /tmp/ccbf9qME.s 			page 11


 305 0030 1870     		strb	r0, [r3]
 306              	.LVL28:
 221:rt_thread/src/scheduler.c ****             from_thread         = rt_current_thread;
 222:rt_thread/src/scheduler.c ****             rt_current_thread   = to_thread;
 307              		.loc 1 222 0
 308 0032 1E4B     		ldr	r3, .L29+12
 309 0034 1C60     		str	r4, [r3]
 223:rt_thread/src/scheduler.c **** 
 224:rt_thread/src/scheduler.c ****             RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
 310              		.loc 1 224 0
 311 0036 1F4B     		ldr	r3, .L29+20
 312 0038 1B68     		ldr	r3, [r3]
 313 003a 13B1     		cbz	r3, .L24
 314              		.loc 1 224 0 is_stmt 0 discriminator 1
 315 003c 2146     		mov	r1, r4
 316 003e 3046     		mov	r0, r6
 317              	.LVL29:
 318 0040 9847     		blx	r3
 319              	.LVL30:
 320              	.L24:
 225:rt_thread/src/scheduler.c **** 
 226:rt_thread/src/scheduler.c ****             /* switch to new thread */
 227:rt_thread/src/scheduler.c ****             RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
 228:rt_thread/src/scheduler.c ****                          ("[%d]switch to priority#%d "
 229:rt_thread/src/scheduler.c ****                           "thread:%.*s(sp:0x%p), "
 230:rt_thread/src/scheduler.c ****                           "from thread:%.*s(sp: 0x%p)\n",
 231:rt_thread/src/scheduler.c ****                           rt_interrupt_nest, highest_ready_priority,
 232:rt_thread/src/scheduler.c ****                           RT_NAME_MAX, to_thread->name, to_thread->sp,
 233:rt_thread/src/scheduler.c ****                           RT_NAME_MAX, from_thread->name, from_thread->sp));
 234:rt_thread/src/scheduler.c **** 
 235:rt_thread/src/scheduler.c **** #ifdef RT_USING_OVERFLOW_CHECK
 236:rt_thread/src/scheduler.c ****             _rt_scheduler_stack_check(to_thread);
 321              		.loc 1 236 0 is_stmt 1
 322 0042 2046     		mov	r0, r4
 323 0044 FFF7FEFF 		bl	_rt_scheduler_stack_check
 324              	.LVL31:
 237:rt_thread/src/scheduler.c **** #endif
 238:rt_thread/src/scheduler.c **** 
 239:rt_thread/src/scheduler.c ****             if (rt_interrupt_nest == 0)
 325              		.loc 1 239 0
 326 0048 1B4B     		ldr	r3, .L29+24
 327 004a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 328 004c 13F0FF0F 		tst	r3, #255
 329 0050 1BD1     		bne	.L25
 240:rt_thread/src/scheduler.c ****             {
 241:rt_thread/src/scheduler.c ****                 rt_hw_context_switch((rt_ubase_t)&from_thread->sp,
 330              		.loc 1 241 0
 331 0052 07F10801 		add	r1, r7, #8
 332 0056 06F11C00 		add	r0, r6, #28
 333 005a FFF7FEFF 		bl	rt_hw_context_switch
 334              	.LVL32:
 242:rt_thread/src/scheduler.c ****                                      (rt_ubase_t)&to_thread->sp);
 243:rt_thread/src/scheduler.c **** 
 244:rt_thread/src/scheduler.c **** #ifdef RT_USING_SIGNALS
 245:rt_thread/src/scheduler.c ****                 if (rt_current_thread->stat & RT_THREAD_STAT_SIGNAL_PENDING)
 335              		.loc 1 245 0
 336 005e 134B     		ldr	r3, .L29+12
ARM GAS  /tmp/ccbf9qME.s 			page 12


 337 0060 1A68     		ldr	r2, [r3]
 338 0062 92F83430 		ldrb	r3, [r2, #52]	@ zero_extendqisi2
 339 0066 13F0400F 		tst	r3, #64
 340 006a 0AD0     		beq	.L26
 341              	.LBB18:
 246:rt_thread/src/scheduler.c ****                 {
 247:rt_thread/src/scheduler.c ****                     extern void rt_thread_handle_sig(rt_bool_t clean_state);
 248:rt_thread/src/scheduler.c **** 
 249:rt_thread/src/scheduler.c ****                     rt_current_thread->stat &= ~RT_THREAD_STAT_SIGNAL_PENDING;
 342              		.loc 1 249 0
 343 006c 23F04003 		bic	r3, r3, #64
 344 0070 82F83430 		strb	r3, [r2, #52]
 250:rt_thread/src/scheduler.c **** 
 251:rt_thread/src/scheduler.c ****                     rt_hw_interrupt_enable(level);
 345              		.loc 1 251 0
 346 0074 2846     		mov	r0, r5
 347 0076 FFF7FEFF 		bl	rt_hw_interrupt_enable
 348              	.LVL33:
 252:rt_thread/src/scheduler.c **** 
 253:rt_thread/src/scheduler.c ****                     /* check signal status */
 254:rt_thread/src/scheduler.c ****                     rt_thread_handle_sig(RT_TRUE);
 349              		.loc 1 254 0
 350 007a 0120     		movs	r0, #1
 351 007c FFF7FEFF 		bl	rt_thread_handle_sig
 352              	.LVL34:
 353              	.LBE18:
 354 0080 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 355              	.LVL35:
 356              	.L26:
 255:rt_thread/src/scheduler.c ****                 }
 256:rt_thread/src/scheduler.c ****                 else
 257:rt_thread/src/scheduler.c **** #endif
 258:rt_thread/src/scheduler.c ****                 {
 259:rt_thread/src/scheduler.c ****                     /* enable interrupt */
 260:rt_thread/src/scheduler.c ****                     rt_hw_interrupt_enable(level);
 357              		.loc 1 260 0
 358 0082 2846     		mov	r0, r5
 359 0084 FFF7FEFF 		bl	rt_hw_interrupt_enable
 360              	.LVL36:
 361 0088 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 362              	.LVL37:
 363              	.L25:
 261:rt_thread/src/scheduler.c ****                 }
 262:rt_thread/src/scheduler.c **** 
 263:rt_thread/src/scheduler.c ****                 return ;
 264:rt_thread/src/scheduler.c ****             }
 265:rt_thread/src/scheduler.c ****             else
 266:rt_thread/src/scheduler.c ****             {
 267:rt_thread/src/scheduler.c ****                 RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));
 268:rt_thread/src/scheduler.c **** 
 269:rt_thread/src/scheduler.c ****                 rt_hw_context_switch_interrupt((rt_ubase_t)&from_thread->sp,
 364              		.loc 1 269 0
 365 008a 07F10801 		add	r1, r7, #8
 366 008e 06F11C00 		add	r0, r6, #28
 367 0092 FFF7FEFF 		bl	rt_hw_context_switch_interrupt
 368              	.LVL38:
 369              	.L23:
ARM GAS  /tmp/ccbf9qME.s 			page 13


 370              	.LBE17:
 270:rt_thread/src/scheduler.c ****                                                (rt_ubase_t)&to_thread->sp);
 271:rt_thread/src/scheduler.c ****             }
 272:rt_thread/src/scheduler.c ****         }
 273:rt_thread/src/scheduler.c ****     }
 274:rt_thread/src/scheduler.c **** 
 275:rt_thread/src/scheduler.c ****     /* enable interrupt */
 276:rt_thread/src/scheduler.c ****     rt_hw_interrupt_enable(level);
 371              		.loc 1 276 0
 372 0096 2846     		mov	r0, r5
 373 0098 FFF7FEFF 		bl	rt_hw_interrupt_enable
 374              	.LVL39:
 375 009c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 376              	.LVL40:
 377              	.L30:
 378 009e 00BF     		.align	2
 379              	.L29:
 380 00a0 00000000 		.word	.LANCHOR2
 381 00a4 00000000 		.word	rt_thread_ready_priority_group
 382 00a8 00000000 		.word	rt_thread_priority_table
 383 00ac 00000000 		.word	rt_current_thread
 384 00b0 00000000 		.word	rt_current_priority
 385 00b4 00000000 		.word	.LANCHOR1
 386 00b8 00000000 		.word	rt_interrupt_nest
 387              		.cfi_endproc
 388              	.LFE19:
 390              		.section	.text.rt_schedule_insert_thread,"ax",%progbits
 391              		.align	2
 392              		.global	rt_schedule_insert_thread
 393              		.thumb
 394              		.thumb_func
 396              	rt_schedule_insert_thread:
 397              	.LFB20:
 277:rt_thread/src/scheduler.c **** }
 278:rt_thread/src/scheduler.c **** 
 279:rt_thread/src/scheduler.c **** /*
 280:rt_thread/src/scheduler.c ****  * This function will insert a thread to system ready queue. The state of
 281:rt_thread/src/scheduler.c ****  * thread will be set as READY and remove from suspend queue.
 282:rt_thread/src/scheduler.c ****  *
 283:rt_thread/src/scheduler.c ****  * @param thread the thread to be inserted
 284:rt_thread/src/scheduler.c ****  * @note Please do not invoke this function in user application.
 285:rt_thread/src/scheduler.c ****  */
 286:rt_thread/src/scheduler.c **** void rt_schedule_insert_thread(struct rt_thread *thread)
 287:rt_thread/src/scheduler.c **** {
 398              		.loc 1 287 0
 399              		.cfi_startproc
 400              		@ args = 0, pretend = 0, frame = 0
 401              		@ frame_needed = 0, uses_anonymous_args = 0
 402              	.LVL41:
 403 0000 10B5     		push	{r4, lr}
 404              	.LCFI3:
 405              		.cfi_def_cfa_offset 8
 406              		.cfi_offset 4, -8
 407              		.cfi_offset 14, -4
 288:rt_thread/src/scheduler.c ****     register rt_base_t temp;
 289:rt_thread/src/scheduler.c **** 
 290:rt_thread/src/scheduler.c ****     RT_ASSERT(thread != RT_NULL);
ARM GAS  /tmp/ccbf9qME.s 			page 14


 408              		.loc 1 290 0
 409 0002 0446     		mov	r4, r0
 410 0004 28B9     		cbnz	r0, .L32
 411              		.loc 1 290 0 is_stmt 0 discriminator 1
 412 0006 4FF49172 		mov	r2, #290
 413 000a 1149     		ldr	r1, .L34
 414 000c 1148     		ldr	r0, .L34+4
 415              	.LVL42:
 416 000e FFF7FEFF 		bl	rt_assert_handler
 417              	.LVL43:
 418              	.L32:
 291:rt_thread/src/scheduler.c **** 
 292:rt_thread/src/scheduler.c ****     /* disable interrupt */
 293:rt_thread/src/scheduler.c ****     temp = rt_hw_interrupt_disable();
 419              		.loc 1 293 0 is_stmt 1
 420 0012 FFF7FEFF 		bl	rt_hw_interrupt_disable
 421              	.LVL44:
 294:rt_thread/src/scheduler.c **** 
 295:rt_thread/src/scheduler.c ****     /* change stat */
 296:rt_thread/src/scheduler.c ****     thread->stat = RT_THREAD_READY | (thread->stat & ~RT_THREAD_STAT_MASK);
 422              		.loc 1 296 0
 423 0016 94F83430 		ldrb	r3, [r4, #52]	@ zero_extendqisi2
 424 001a 23F00F03 		bic	r3, r3, #15
 425 001e 43F00103 		orr	r3, r3, #1
 426 0022 84F83430 		strb	r3, [r4, #52]
 297:rt_thread/src/scheduler.c **** 
 298:rt_thread/src/scheduler.c ****     /* insert thread to ready list */
 299:rt_thread/src/scheduler.c ****     rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
 427              		.loc 1 299 0
 428 0026 94F83520 		ldrb	r2, [r4, #53]	@ zero_extendqisi2
 429 002a 0B4B     		ldr	r3, .L34+8
 430 002c 03EBC203 		add	r3, r3, r2, lsl #3
 431 0030 04F11402 		add	r2, r4, #20
 432              	.LVL45:
 433              	.LBB19:
 434              	.LBB20:
  50:rt_thread/include/rtservice.h **** }
  51:rt_thread/include/rtservice.h **** 
  52:rt_thread/include/rtservice.h **** /**
  53:rt_thread/include/rtservice.h ****  * @brief insert a node after a list
  54:rt_thread/include/rtservice.h ****  *
  55:rt_thread/include/rtservice.h ****  * @param l list to insert it
  56:rt_thread/include/rtservice.h ****  * @param n new node to be inserted
  57:rt_thread/include/rtservice.h ****  */
  58:rt_thread/include/rtservice.h **** rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
  59:rt_thread/include/rtservice.h **** {
  60:rt_thread/include/rtservice.h ****     l->next->prev = n;
  61:rt_thread/include/rtservice.h ****     n->next = l->next;
  62:rt_thread/include/rtservice.h **** 
  63:rt_thread/include/rtservice.h ****     l->next = n;
  64:rt_thread/include/rtservice.h ****     n->prev = l;
  65:rt_thread/include/rtservice.h **** }
  66:rt_thread/include/rtservice.h **** 
  67:rt_thread/include/rtservice.h **** /**
  68:rt_thread/include/rtservice.h ****  * @brief insert a node before a list
  69:rt_thread/include/rtservice.h ****  *
  70:rt_thread/include/rtservice.h ****  * @param n new node to be inserted
ARM GAS  /tmp/ccbf9qME.s 			page 15


  71:rt_thread/include/rtservice.h ****  * @param l list to insert it
  72:rt_thread/include/rtservice.h ****  */
  73:rt_thread/include/rtservice.h **** rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
  74:rt_thread/include/rtservice.h **** {
  75:rt_thread/include/rtservice.h ****     l->prev->next = n;
 435              		.loc 2 75 0
 436 0034 5968     		ldr	r1, [r3, #4]
 437 0036 0A60     		str	r2, [r1]
  76:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 438              		.loc 2 76 0
 439 0038 5968     		ldr	r1, [r3, #4]
 440 003a A161     		str	r1, [r4, #24]
  77:rt_thread/include/rtservice.h **** 
  78:rt_thread/include/rtservice.h ****     l->prev = n;
 441              		.loc 2 78 0
 442 003c 5A60     		str	r2, [r3, #4]
  79:rt_thread/include/rtservice.h ****     n->next = l;
 443              		.loc 2 79 0
 444 003e 6361     		str	r3, [r4, #20]
 445              	.LVL46:
 446              	.LBE20:
 447              	.LBE19:
 300:rt_thread/src/scheduler.c ****                           &(thread->tlist));
 301:rt_thread/src/scheduler.c **** 
 302:rt_thread/src/scheduler.c ****     /* set priority mask */
 303:rt_thread/src/scheduler.c **** #if RT_THREAD_PRIORITY_MAX <= 32
 304:rt_thread/src/scheduler.c ****     RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("insert thread[%.*s], the priority: %d\n",
 305:rt_thread/src/scheduler.c ****                                       RT_NAME_MAX, thread->name, thread->current_priority));
 306:rt_thread/src/scheduler.c **** #else
 307:rt_thread/src/scheduler.c ****     RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
 308:rt_thread/src/scheduler.c ****                  ("insert thread[%.*s], the priority: %d 0x%x %d\n",
 309:rt_thread/src/scheduler.c ****                   RT_NAME_MAX,
 310:rt_thread/src/scheduler.c ****                   thread->name,
 311:rt_thread/src/scheduler.c ****                   thread->number,
 312:rt_thread/src/scheduler.c ****                   thread->number_mask,
 313:rt_thread/src/scheduler.c ****                   thread->high_mask));
 314:rt_thread/src/scheduler.c **** #endif
 315:rt_thread/src/scheduler.c **** 
 316:rt_thread/src/scheduler.c **** #if RT_THREAD_PRIORITY_MAX > 32
 317:rt_thread/src/scheduler.c ****     rt_thread_ready_table[thread->number] |= thread->high_mask;
 318:rt_thread/src/scheduler.c **** #endif
 319:rt_thread/src/scheduler.c ****     rt_thread_ready_priority_group |= thread->number_mask;
 448              		.loc 1 319 0
 449 0040 A36B     		ldr	r3, [r4, #56]
 450 0042 064A     		ldr	r2, .L34+12
 451 0044 1168     		ldr	r1, [r2]
 452 0046 0B43     		orrs	r3, r3, r1
 453 0048 1360     		str	r3, [r2]
 320:rt_thread/src/scheduler.c **** 
 321:rt_thread/src/scheduler.c ****     /* enable interrupt */
 322:rt_thread/src/scheduler.c ****     rt_hw_interrupt_enable(temp);
 454              		.loc 1 322 0
 455 004a FFF7FEFF 		bl	rt_hw_interrupt_enable
 456              	.LVL47:
 457 004e 10BD     		pop	{r4, pc}
 458              	.LVL48:
 459              	.L35:
ARM GAS  /tmp/ccbf9qME.s 			page 16


 460              		.align	2
 461              	.L34:
 462 0050 00000000 		.word	.LANCHOR3
 463 0054 00000000 		.word	.LC0
 464 0058 00000000 		.word	rt_thread_priority_table
 465 005c 00000000 		.word	rt_thread_ready_priority_group
 466              		.cfi_endproc
 467              	.LFE20:
 469              		.section	.text.rt_schedule_remove_thread,"ax",%progbits
 470              		.align	2
 471              		.global	rt_schedule_remove_thread
 472              		.thumb
 473              		.thumb_func
 475              	rt_schedule_remove_thread:
 476              	.LFB21:
 323:rt_thread/src/scheduler.c **** }
 324:rt_thread/src/scheduler.c **** 
 325:rt_thread/src/scheduler.c **** /*
 326:rt_thread/src/scheduler.c ****  * This function will remove a thread from system ready queue.
 327:rt_thread/src/scheduler.c ****  *
 328:rt_thread/src/scheduler.c ****  * @param thread the thread to be removed
 329:rt_thread/src/scheduler.c ****  *
 330:rt_thread/src/scheduler.c ****  * @note Please do not invoke this function in user application.
 331:rt_thread/src/scheduler.c ****  */
 332:rt_thread/src/scheduler.c **** void rt_schedule_remove_thread(struct rt_thread *thread)
 333:rt_thread/src/scheduler.c **** {
 477              		.loc 1 333 0
 478              		.cfi_startproc
 479              		@ args = 0, pretend = 0, frame = 0
 480              		@ frame_needed = 0, uses_anonymous_args = 0
 481              	.LVL49:
 482 0000 10B5     		push	{r4, lr}
 483              	.LCFI4:
 484              		.cfi_def_cfa_offset 8
 485              		.cfi_offset 4, -8
 486              		.cfi_offset 14, -4
 334:rt_thread/src/scheduler.c ****     register rt_base_t temp;
 335:rt_thread/src/scheduler.c **** 
 336:rt_thread/src/scheduler.c ****     RT_ASSERT(thread != RT_NULL);
 487              		.loc 1 336 0
 488 0002 0446     		mov	r4, r0
 489 0004 28B9     		cbnz	r0, .L37
 490              		.loc 1 336 0 is_stmt 0 discriminator 1
 491 0006 4FF4A872 		mov	r2, #336
 492 000a 1149     		ldr	r1, .L40
 493 000c 1148     		ldr	r0, .L40+4
 494              	.LVL50:
 495 000e FFF7FEFF 		bl	rt_assert_handler
 496              	.LVL51:
 497              	.L37:
 337:rt_thread/src/scheduler.c **** 
 338:rt_thread/src/scheduler.c ****     /* disable interrupt */
 339:rt_thread/src/scheduler.c ****     temp = rt_hw_interrupt_disable();
 498              		.loc 1 339 0 is_stmt 1
 499 0012 FFF7FEFF 		bl	rt_hw_interrupt_disable
 500              	.LVL52:
 340:rt_thread/src/scheduler.c **** 
ARM GAS  /tmp/ccbf9qME.s 			page 17


 341:rt_thread/src/scheduler.c **** #if RT_THREAD_PRIORITY_MAX <= 32
 342:rt_thread/src/scheduler.c ****     RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
 343:rt_thread/src/scheduler.c ****                                       RT_NAME_MAX, thread->name,
 344:rt_thread/src/scheduler.c ****                                       thread->current_priority));
 345:rt_thread/src/scheduler.c **** #else
 346:rt_thread/src/scheduler.c ****     RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
 347:rt_thread/src/scheduler.c ****                  ("remove thread[%.*s], the priority: %d 0x%x %d\n",
 348:rt_thread/src/scheduler.c ****                   RT_NAME_MAX,
 349:rt_thread/src/scheduler.c ****                   thread->name,
 350:rt_thread/src/scheduler.c ****                   thread->number,
 351:rt_thread/src/scheduler.c ****                   thread->number_mask,
 352:rt_thread/src/scheduler.c ****                   thread->high_mask));
 353:rt_thread/src/scheduler.c **** #endif
 354:rt_thread/src/scheduler.c **** 
 355:rt_thread/src/scheduler.c ****     /* remove thread from ready list */
 356:rt_thread/src/scheduler.c ****     rt_list_remove(&(thread->tlist));
 501              		.loc 1 356 0
 502 0016 04F11403 		add	r3, r4, #20
 503              	.LBB21:
 504              	.LBB22:
  80:rt_thread/include/rtservice.h **** }
  81:rt_thread/include/rtservice.h **** 
  82:rt_thread/include/rtservice.h **** /**
  83:rt_thread/include/rtservice.h ****  * @brief remove node from list.
  84:rt_thread/include/rtservice.h ****  * @param n the node to remove from the list.
  85:rt_thread/include/rtservice.h ****  */
  86:rt_thread/include/rtservice.h **** rt_inline void rt_list_remove(rt_list_t *n)
  87:rt_thread/include/rtservice.h **** {
  88:rt_thread/include/rtservice.h ****     n->next->prev = n->prev;
 505              		.loc 2 88 0
 506 001a 6269     		ldr	r2, [r4, #20]
 507 001c A169     		ldr	r1, [r4, #24]
 508 001e 5160     		str	r1, [r2, #4]
  89:rt_thread/include/rtservice.h ****     n->prev->next = n->next;
 509              		.loc 2 89 0
 510 0020 A269     		ldr	r2, [r4, #24]
 511 0022 6169     		ldr	r1, [r4, #20]
 512 0024 1160     		str	r1, [r2]
  90:rt_thread/include/rtservice.h **** 
  91:rt_thread/include/rtservice.h ****     n->next = n->prev = n;
 513              		.loc 2 91 0
 514 0026 A361     		str	r3, [r4, #24]
 515 0028 6361     		str	r3, [r4, #20]
 516              	.LBE22:
 517              	.LBE21:
 357:rt_thread/src/scheduler.c ****     if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
 518              		.loc 1 357 0
 519 002a 94F83520 		ldrb	r2, [r4, #53]	@ zero_extendqisi2
 520 002e 0A4B     		ldr	r3, .L40+8
 521 0030 03EBC201 		add	r1, r3, r2, lsl #3
 522              	.LVL53:
 523              	.LBB23:
 524              	.LBB24:
  92:rt_thread/include/rtservice.h **** }
  93:rt_thread/include/rtservice.h **** 
  94:rt_thread/include/rtservice.h **** /**
  95:rt_thread/include/rtservice.h ****  * @brief tests whether a list is empty
ARM GAS  /tmp/ccbf9qME.s 			page 18


  96:rt_thread/include/rtservice.h ****  * @param l the list to test.
  97:rt_thread/include/rtservice.h ****  */
  98:rt_thread/include/rtservice.h **** rt_inline int rt_list_isempty(const rt_list_t *l)
  99:rt_thread/include/rtservice.h **** {
 100:rt_thread/include/rtservice.h ****     return l->next == l;
 525              		.loc 2 100 0
 526 0034 53F83230 		ldr	r3, [r3, r2, lsl #3]
 527              	.LVL54:
 528              	.LBE24:
 529              	.LBE23:
 530              		.loc 1 357 0
 531 0038 9942     		cmp	r1, r3
 532 003a 05D1     		bne	.L38
 358:rt_thread/src/scheduler.c ****     {
 359:rt_thread/src/scheduler.c **** #if RT_THREAD_PRIORITY_MAX > 32
 360:rt_thread/src/scheduler.c ****         rt_thread_ready_table[thread->number] &= ~thread->high_mask;
 361:rt_thread/src/scheduler.c ****         if (rt_thread_ready_table[thread->number] == 0)
 362:rt_thread/src/scheduler.c ****         {
 363:rt_thread/src/scheduler.c ****             rt_thread_ready_priority_group &= ~thread->number_mask;
 364:rt_thread/src/scheduler.c ****         }
 365:rt_thread/src/scheduler.c **** #else
 366:rt_thread/src/scheduler.c ****         rt_thread_ready_priority_group &= ~thread->number_mask;
 533              		.loc 1 366 0
 534 003c A16B     		ldr	r1, [r4, #56]
 535 003e 074A     		ldr	r2, .L40+12
 536 0040 1368     		ldr	r3, [r2]
 537 0042 23EA0103 		bic	r3, r3, r1
 538 0046 1360     		str	r3, [r2]
 539              	.L38:
 367:rt_thread/src/scheduler.c **** #endif
 368:rt_thread/src/scheduler.c ****     }
 369:rt_thread/src/scheduler.c **** 
 370:rt_thread/src/scheduler.c ****     /* enable interrupt */
 371:rt_thread/src/scheduler.c ****     rt_hw_interrupt_enable(temp);
 540              		.loc 1 371 0
 541 0048 FFF7FEFF 		bl	rt_hw_interrupt_enable
 542              	.LVL55:
 543 004c 10BD     		pop	{r4, pc}
 544              	.LVL56:
 545              	.L41:
 546 004e 00BF     		.align	2
 547              	.L40:
 548 0050 00000000 		.word	.LANCHOR4
 549 0054 00000000 		.word	.LC0
 550 0058 00000000 		.word	rt_thread_priority_table
 551 005c 00000000 		.word	rt_thread_ready_priority_group
 552              		.cfi_endproc
 553              	.LFE21:
 555              		.section	.text.rt_enter_critical,"ax",%progbits
 556              		.align	2
 557              		.global	rt_enter_critical
 558              		.thumb
 559              		.thumb_func
 561              	rt_enter_critical:
 562              	.LFB22:
 372:rt_thread/src/scheduler.c **** }
 373:rt_thread/src/scheduler.c **** 
ARM GAS  /tmp/ccbf9qME.s 			page 19


 374:rt_thread/src/scheduler.c **** /**
 375:rt_thread/src/scheduler.c ****  * This function will lock the thread scheduler.
 376:rt_thread/src/scheduler.c ****  */
 377:rt_thread/src/scheduler.c **** void rt_enter_critical(void)
 378:rt_thread/src/scheduler.c **** {
 563              		.loc 1 378 0
 564              		.cfi_startproc
 565              		@ args = 0, pretend = 0, frame = 0
 566              		@ frame_needed = 0, uses_anonymous_args = 0
 567 0000 08B5     		push	{r3, lr}
 568              	.LCFI5:
 569              		.cfi_def_cfa_offset 8
 570              		.cfi_offset 3, -8
 571              		.cfi_offset 14, -4
 379:rt_thread/src/scheduler.c ****     register rt_base_t level;
 380:rt_thread/src/scheduler.c **** 
 381:rt_thread/src/scheduler.c ****     /* disable interrupt */
 382:rt_thread/src/scheduler.c ****     level = rt_hw_interrupt_disable();
 572              		.loc 1 382 0
 573 0002 FFF7FEFF 		bl	rt_hw_interrupt_disable
 574              	.LVL57:
 383:rt_thread/src/scheduler.c **** 
 384:rt_thread/src/scheduler.c ****     /*
 385:rt_thread/src/scheduler.c ****      * the maximal number of nest is RT_UINT16_MAX, which is big
 386:rt_thread/src/scheduler.c ****      * enough and does not check here
 387:rt_thread/src/scheduler.c ****      */
 388:rt_thread/src/scheduler.c ****     rt_scheduler_lock_nest ++;
 575              		.loc 1 388 0
 576 0006 034A     		ldr	r2, .L44
 577 0008 1388     		ldrh	r3, [r2]
 578 000a 0133     		adds	r3, r3, #1
 579 000c 1380     		strh	r3, [r2]	@ movhi
 389:rt_thread/src/scheduler.c **** 
 390:rt_thread/src/scheduler.c ****     /* enable interrupt */
 391:rt_thread/src/scheduler.c ****     rt_hw_interrupt_enable(level);
 580              		.loc 1 391 0
 581 000e FFF7FEFF 		bl	rt_hw_interrupt_enable
 582              	.LVL58:
 583 0012 08BD     		pop	{r3, pc}
 584              	.L45:
 585              		.align	2
 586              	.L44:
 587 0014 00000000 		.word	.LANCHOR2
 588              		.cfi_endproc
 589              	.LFE22:
 591              		.section	.text.rt_exit_critical,"ax",%progbits
 592              		.align	2
 593              		.global	rt_exit_critical
 594              		.thumb
 595              		.thumb_func
 597              	rt_exit_critical:
 598              	.LFB23:
 392:rt_thread/src/scheduler.c **** }
 393:rt_thread/src/scheduler.c **** RTM_EXPORT(rt_enter_critical);
 394:rt_thread/src/scheduler.c **** 
 395:rt_thread/src/scheduler.c **** /**
 396:rt_thread/src/scheduler.c ****  * This function will unlock the thread scheduler.
ARM GAS  /tmp/ccbf9qME.s 			page 20


 397:rt_thread/src/scheduler.c ****  */
 398:rt_thread/src/scheduler.c **** void rt_exit_critical(void)
 399:rt_thread/src/scheduler.c **** {
 599              		.loc 1 399 0
 600              		.cfi_startproc
 601              		@ args = 0, pretend = 0, frame = 0
 602              		@ frame_needed = 0, uses_anonymous_args = 0
 603 0000 08B5     		push	{r3, lr}
 604              	.LCFI6:
 605              		.cfi_def_cfa_offset 8
 606              		.cfi_offset 3, -8
 607              		.cfi_offset 14, -4
 400:rt_thread/src/scheduler.c ****     register rt_base_t level;
 401:rt_thread/src/scheduler.c **** 
 402:rt_thread/src/scheduler.c ****     /* disable interrupt */
 403:rt_thread/src/scheduler.c ****     level = rt_hw_interrupt_disable();
 608              		.loc 1 403 0
 609 0002 FFF7FEFF 		bl	rt_hw_interrupt_disable
 610              	.LVL59:
 404:rt_thread/src/scheduler.c **** 
 405:rt_thread/src/scheduler.c ****     rt_scheduler_lock_nest --;
 611              		.loc 1 405 0
 612 0006 0A4A     		ldr	r2, .L50
 613 0008 1388     		ldrh	r3, [r2]
 614 000a 013B     		subs	r3, r3, #1
 615 000c 1BB2     		sxth	r3, r3
 616 000e 1380     		strh	r3, [r2]	@ movhi
 406:rt_thread/src/scheduler.c ****     if (rt_scheduler_lock_nest <= 0)
 617              		.loc 1 406 0
 618 0010 002B     		cmp	r3, #0
 619 0012 0ADC     		bgt	.L47
 407:rt_thread/src/scheduler.c ****     {
 408:rt_thread/src/scheduler.c ****         rt_scheduler_lock_nest = 0;
 620              		.loc 1 408 0
 621 0014 0022     		movs	r2, #0
 622 0016 064B     		ldr	r3, .L50
 623 0018 1A80     		strh	r2, [r3]	@ movhi
 409:rt_thread/src/scheduler.c ****         /* enable interrupt */
 410:rt_thread/src/scheduler.c ****         rt_hw_interrupt_enable(level);
 624              		.loc 1 410 0
 625 001a FFF7FEFF 		bl	rt_hw_interrupt_enable
 626              	.LVL60:
 411:rt_thread/src/scheduler.c **** 
 412:rt_thread/src/scheduler.c ****         if (rt_current_thread)
 627              		.loc 1 412 0
 628 001e 054B     		ldr	r3, .L50+4
 629 0020 1B68     		ldr	r3, [r3]
 630 0022 23B1     		cbz	r3, .L46
 413:rt_thread/src/scheduler.c ****         {
 414:rt_thread/src/scheduler.c ****             /* if scheduler is started, do a schedule */
 415:rt_thread/src/scheduler.c ****             rt_schedule();
 631              		.loc 1 415 0
 632 0024 FFF7FEFF 		bl	rt_schedule
 633              	.LVL61:
 634 0028 08BD     		pop	{r3, pc}
 635              	.LVL62:
 636              	.L47:
ARM GAS  /tmp/ccbf9qME.s 			page 21


 416:rt_thread/src/scheduler.c ****         }
 417:rt_thread/src/scheduler.c ****     }
 418:rt_thread/src/scheduler.c ****     else
 419:rt_thread/src/scheduler.c ****     {
 420:rt_thread/src/scheduler.c ****         /* enable interrupt */
 421:rt_thread/src/scheduler.c ****         rt_hw_interrupt_enable(level);
 637              		.loc 1 421 0
 638 002a FFF7FEFF 		bl	rt_hw_interrupt_enable
 639              	.LVL63:
 640              	.L46:
 641 002e 08BD     		pop	{r3, pc}
 642              	.L51:
 643              		.align	2
 644              	.L50:
 645 0030 00000000 		.word	.LANCHOR2
 646 0034 00000000 		.word	rt_current_thread
 647              		.cfi_endproc
 648              	.LFE23:
 650              		.section	.text.rt_critical_level,"ax",%progbits
 651              		.align	2
 652              		.global	rt_critical_level
 653              		.thumb
 654              		.thumb_func
 656              	rt_critical_level:
 657              	.LFB24:
 422:rt_thread/src/scheduler.c ****     }
 423:rt_thread/src/scheduler.c **** }
 424:rt_thread/src/scheduler.c **** RTM_EXPORT(rt_exit_critical);
 425:rt_thread/src/scheduler.c **** 
 426:rt_thread/src/scheduler.c **** /**
 427:rt_thread/src/scheduler.c ****  * Get the scheduler lock level
 428:rt_thread/src/scheduler.c ****  *
 429:rt_thread/src/scheduler.c ****  * @return the level of the scheduler lock. 0 means unlocked.
 430:rt_thread/src/scheduler.c ****  */
 431:rt_thread/src/scheduler.c **** rt_uint16_t rt_critical_level(void)
 432:rt_thread/src/scheduler.c **** {
 658              		.loc 1 432 0
 659              		.cfi_startproc
 660              		@ args = 0, pretend = 0, frame = 0
 661              		@ frame_needed = 0, uses_anonymous_args = 0
 662              		@ link register save eliminated.
 433:rt_thread/src/scheduler.c ****     return rt_scheduler_lock_nest;
 434:rt_thread/src/scheduler.c **** }
 663              		.loc 1 434 0
 664 0000 014B     		ldr	r3, .L53
 665 0002 1888     		ldrh	r0, [r3]
 666 0004 7047     		bx	lr
 667              	.L54:
 668 0006 00BF     		.align	2
 669              	.L53:
 670 0008 00000000 		.word	.LANCHOR2
 671              		.cfi_endproc
 672              	.LFE24:
 674              		.comm	rt_thread_defunct,8,4
 675              		.comm	rt_thread_ready_priority_group,4,4
 676              		.comm	rt_current_priority,1,1
 677              		.comm	rt_current_thread,4,4
ARM GAS  /tmp/ccbf9qME.s 			page 22


 678              		.comm	rt_thread_priority_table,256,4
 679              		.section	.rodata.__FUNCTION__.5347,"a",%progbits
 680              		.align	2
 681              		.set	.LANCHOR3,. + 0
 684              	__FUNCTION__.5347:
 685 0000 72745F73 		.ascii	"rt_schedule_insert_thread\000"
 685      63686564 
 685      756C655F 
 685      696E7365 
 685      72745F74 
 686              		.section	.rodata.__FUNCTION__.5352,"a",%progbits
 687              		.align	2
 688              		.set	.LANCHOR4,. + 0
 691              	__FUNCTION__.5352:
 692 0000 72745F73 		.ascii	"rt_schedule_remove_thread\000"
 692      63686564 
 692      756C655F 
 692      72656D6F 
 692      76655F74 
 693              		.section	.bss.rt_scheduler_lock_nest,"aw",%nobits
 694              		.align	1
 695              		.set	.LANCHOR2,. + 0
 698              	rt_scheduler_lock_nest:
 699 0000 0000     		.space	2
 700              		.section	.rodata.__FUNCTION__.5316,"a",%progbits
 701              		.align	2
 702              		.set	.LANCHOR0,. + 0
 705              	__FUNCTION__.5316:
 706 0000 5F72745F 		.ascii	"_rt_scheduler_stack_check\000"
 706      73636865 
 706      64756C65 
 706      725F7374 
 706      61636B5F 
 707              		.section	.rodata.str1.4,"aMS",%progbits,1
 708              		.align	2
 709              	.LC0:
 710 0000 74687265 		.ascii	"thread != RT_NULL\000"
 710      61642021 
 710      3D205254 
 710      5F4E554C 
 710      4C00
 711 0012 0000     		.space	2
 712              	.LC1:
 713 0014 74687265 		.ascii	"thread:%s stack overflow\012\000"
 713      61643A25 
 713      73207374 
 713      61636B20 
 713      6F766572 
 714 002e 0000     		.space	2
 715              	.LC2:
 716 0030 7761726E 		.ascii	"warning: %s stack is close to end of stack address."
 716      696E673A 
 716      20257320 
 716      73746163 
 716      6B206973 
 717 0063 0A00     		.ascii	"\012\000"
 718              		.section	.bss.rt_scheduler_hook,"aw",%nobits
ARM GAS  /tmp/ccbf9qME.s 			page 23


 719              		.align	2
 720              		.set	.LANCHOR1,. + 0
 723              	rt_scheduler_hook:
 724 0000 00000000 		.space	4
 725              		.text
 726              	.Letext0:
 727              		.file 3 "rt_thread/include/rtdef.h"
 728              		.file 4 "rt_thread/include/rtthread.h"
 729              		.file 5 "rt_thread/include/rthw.h"
ARM GAS  /tmp/ccbf9qME.s 			page 24


DEFINED SYMBOLS
                            *ABS*:0000000000000000 scheduler.c
     /tmp/ccbf9qME.s:20     .text._rt_scheduler_stack_check:0000000000000000 $t
     /tmp/ccbf9qME.s:24     .text._rt_scheduler_stack_check:0000000000000000 _rt_scheduler_stack_check
     /tmp/ccbf9qME.s:97     .text._rt_scheduler_stack_check:0000000000000048 $d
     /tmp/ccbf9qME.s:105    .text.rt_scheduler_sethook:0000000000000000 $t
     /tmp/ccbf9qME.s:110    .text.rt_scheduler_sethook:0000000000000000 rt_scheduler_sethook
     /tmp/ccbf9qME.s:125    .text.rt_scheduler_sethook:0000000000000008 $d
     /tmp/ccbf9qME.s:130    .text.rt_system_scheduler_init:0000000000000000 $t
     /tmp/ccbf9qME.s:135    .text.rt_system_scheduler_init:0000000000000000 rt_system_scheduler_init
     /tmp/ccbf9qME.s:195    .text.rt_system_scheduler_init:0000000000000034 $d
                            *COM*:0000000000000100 rt_thread_priority_table
                            *COM*:0000000000000001 rt_current_priority
                            *COM*:0000000000000004 rt_current_thread
                            *COM*:0000000000000004 rt_thread_ready_priority_group
                            *COM*:0000000000000008 rt_thread_defunct
     /tmp/ccbf9qME.s:207    .text.rt_system_scheduler_start:0000000000000000 $t
     /tmp/ccbf9qME.s:212    .text.rt_system_scheduler_start:0000000000000000 rt_system_scheduler_start
     /tmp/ccbf9qME.s:247    .text.rt_system_scheduler_start:0000000000000024 $d
     /tmp/ccbf9qME.s:254    .text.rt_schedule:0000000000000000 $t
     /tmp/ccbf9qME.s:259    .text.rt_schedule:0000000000000000 rt_schedule
     /tmp/ccbf9qME.s:380    .text.rt_schedule:00000000000000a0 $d
     /tmp/ccbf9qME.s:391    .text.rt_schedule_insert_thread:0000000000000000 $t
     /tmp/ccbf9qME.s:396    .text.rt_schedule_insert_thread:0000000000000000 rt_schedule_insert_thread
     /tmp/ccbf9qME.s:462    .text.rt_schedule_insert_thread:0000000000000050 $d
     /tmp/ccbf9qME.s:470    .text.rt_schedule_remove_thread:0000000000000000 $t
     /tmp/ccbf9qME.s:475    .text.rt_schedule_remove_thread:0000000000000000 rt_schedule_remove_thread
     /tmp/ccbf9qME.s:548    .text.rt_schedule_remove_thread:0000000000000050 $d
     /tmp/ccbf9qME.s:556    .text.rt_enter_critical:0000000000000000 $t
     /tmp/ccbf9qME.s:561    .text.rt_enter_critical:0000000000000000 rt_enter_critical
     /tmp/ccbf9qME.s:587    .text.rt_enter_critical:0000000000000014 $d
     /tmp/ccbf9qME.s:592    .text.rt_exit_critical:0000000000000000 $t
     /tmp/ccbf9qME.s:597    .text.rt_exit_critical:0000000000000000 rt_exit_critical
     /tmp/ccbf9qME.s:645    .text.rt_exit_critical:0000000000000030 $d
     /tmp/ccbf9qME.s:651    .text.rt_critical_level:0000000000000000 $t
     /tmp/ccbf9qME.s:656    .text.rt_critical_level:0000000000000000 rt_critical_level
     /tmp/ccbf9qME.s:670    .text.rt_critical_level:0000000000000008 $d
     /tmp/ccbf9qME.s:680    .rodata.__FUNCTION__.5347:0000000000000000 $d
     /tmp/ccbf9qME.s:684    .rodata.__FUNCTION__.5347:0000000000000000 __FUNCTION__.5347
     /tmp/ccbf9qME.s:687    .rodata.__FUNCTION__.5352:0000000000000000 $d
     /tmp/ccbf9qME.s:691    .rodata.__FUNCTION__.5352:0000000000000000 __FUNCTION__.5352
     /tmp/ccbf9qME.s:694    .bss.rt_scheduler_lock_nest:0000000000000000 $d
     /tmp/ccbf9qME.s:698    .bss.rt_scheduler_lock_nest:0000000000000000 rt_scheduler_lock_nest
     /tmp/ccbf9qME.s:701    .rodata.__FUNCTION__.5316:0000000000000000 $d
     /tmp/ccbf9qME.s:705    .rodata.__FUNCTION__.5316:0000000000000000 __FUNCTION__.5316
     /tmp/ccbf9qME.s:708    .rodata.str1.4:0000000000000000 $d
     /tmp/ccbf9qME.s:719    .bss.rt_scheduler_hook:0000000000000000 $d
     /tmp/ccbf9qME.s:723    .bss.rt_scheduler_hook:0000000000000000 rt_scheduler_hook
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
rt_assert_handler
rt_kprintf
rt_hw_interrupt_disable
__rt_ffs
rt_hw_context_switch_to
rt_hw_context_switch
ARM GAS  /tmp/ccbf9qME.s 			page 25


rt_hw_interrupt_enable
rt_thread_handle_sig
rt_hw_context_switch_interrupt
rt_interrupt_nest
